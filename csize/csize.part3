#!/bin/sh
#From lott@informatik.uni-kl.de (Christopher Lott)
#Newsgroups: comp.sources.reviewed
#Subject: REPOST: v04i004:  csize - csize-part3of4, Part03/04
#Date: 17 Oct 1994 16:31:58 -0500
#
#Submitted-by: lott@informatik.uni-kl.de (Christopher Lott)
#Posting-number: Volume 4, Issue 4
#Archive-name: csize/part03
#Environment: ANSI C,FLEX

# This is part 03 of csize
# ============= scan.c.flex ==============
if test -f 'scan.c.flex' -a X"$1" != X"-c"; then
	echo 'x - skipping scan.c.flex (File already exists)'
else
echo 'x - extracting scan.c.flex (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'scan.c.flex' &&
X/* A lexical scanner generated by flex */
X
X/* Scanner skeleton version:
X * $Header: /home/daffy/u0/vern/flex/flex-2.4.7/RCS/flex.skl,v 1.2 94/08/03 11:13:24 vern Exp $
X */
X
X#define FLEX_SCANNER
X
X#include <stdio.h>
X
X
X/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
X#ifdef c_plusplus
X#ifndef __cplusplus
X#define __cplusplus
X#endif
X#endif
X
X
X#ifdef __cplusplus
X
X#include <stdlib.h>
X#include <unistd.h>
X
X/* Use prototypes in function declarations. */
X#define YY_USE_PROTOS
X
X/* The "const" storage-class-modifier is valid. */
X#define YY_USE_CONST
X
X#else	/* ! __cplusplus */
X
X#ifdef __STDC__
X
X#define YY_USE_PROTOS
X#define YY_USE_CONST
X
X#endif	/* __STDC__ */
X#endif	/* ! __cplusplus */
X
X
X#ifdef __TURBOC__
X#define YY_USE_CONST
X#endif
X
X
X#ifndef YY_USE_CONST
X#ifndef const
X#define const
X#endif
X#endif
X
X
X#ifdef YY_USE_PROTOS
X#define YY_PROTO(proto) proto
X#else
X#define YY_PROTO(proto) ()
X#endif
X
X/* Returned upon end-of-file. */
X#define YY_NULL 0
X
X/* Promotes a possibly negative, possibly signed char to an unsigned
X * integer for use as an array index.  If the signed char is negative,
X * we want to instead treat it as an 8-bit unsigned char, hence the
X * double cast.
X */
X#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
X
X/* Enter a start condition.  This macro really ought to take a parameter,
X * but we do it the disgusting crufty way forced on us by the ()-less
X * definition of BEGIN.
X */
X#define BEGIN yy_start = 1 + 2 *
X
X/* Translate the current start state into a value that can be later handed
X * to BEGIN to return to the state.
X */
X#define YY_START ((yy_start - 1) / 2)
X
X/* Action number for EOF rule of a given start state. */
X#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
X
X/* Special action meaning "start processing a new file".  Now included
X * only for backward compatibility with previous versions of flex.
X */
X#define YY_NEW_FILE yyrestart( yyin )
X
X#define YY_END_OF_BUFFER_CHAR 0
X
X/* Size of default input buffer. */
X#define YY_BUF_SIZE 16384
X
Xtypedef struct yy_buffer_state *YY_BUFFER_STATE;
X
Xextern int yyleng;
Xextern FILE *yyin, *yyout;
X
X#ifdef __cplusplus
Xextern "C" {
X#endif
X	extern int yywrap YY_PROTO(( void ));
X#ifdef __cplusplus
X	}
X#endif
X
X#define EOB_ACT_CONTINUE_SCAN 0
X#define EOB_ACT_END_OF_FILE 1
X#define EOB_ACT_LAST_MATCH 2
X
X/* The funky do-while in the following #define is used to turn the definition
X * int a single C statement (which needs a semi-colon terminator).  This
X * avoids problems with code like:
X *
X * 	if ( condition_holds )
X *		yyless( 5 );
X *	else
X *		do_something_else();
X *
X * Prior to using the do-while the compiler would get upset at the
X * "else" because it interpreted the "if" statement as being all
X * done when it reached the ';' after the yyless() call.
X */
X
X/* Return all but the first 'n' matched characters back to the input stream. */
X
X#define yyless(n) \
X	do \
X		{ \
X		/* Undo effects of setting up yytext. */ \
X		*yy_cp = yy_hold_char; \
X		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
X		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
X		} \
X	while ( 0 )
X
X#define unput(c) yyunput( c, yytext_ptr )
X
X
Xstruct yy_buffer_state
X	{
X	FILE *yy_input_file;
X
X	char *yy_ch_buf;		/* input buffer */
X	char *yy_buf_pos;		/* current position in input buffer */
X
X	/* Size of input buffer in bytes, not including room for EOB
X	 * characters.
X	 */
X	int yy_buf_size;
X
X	/* Number of characters read into yy_ch_buf, not including EOB
X	 * characters.
X	 */
X	int yy_n_chars;
X
X	/* Whether this is an "interactive" input source; if so, and
X	 * if we're using stdio for input, then we want to use getc()
X	 * instead of fread(), to make sure we stop fetching input after
X	 * each newline.
X	 */
X	int yy_is_interactive;
X
X	/* Whether to try to fill the input buffer when we reach the
X	 * end of it.
X	 */
X	int yy_fill_buffer;
X
X	int yy_buffer_status;
X#define YY_BUFFER_NEW 0
X#define YY_BUFFER_NORMAL 1
X	/* When an EOF's been seen but there's still some text to process
X	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
X	 * shouldn't try reading from the input source any more.  We might
X	 * still have a bunch of tokens to match, though, because of
X	 * possible backing-up.
X	 *
X	 * When we actually see the EOF, we change the status to "new"
X	 * (via yyrestart()), so that the user can continue scanning by
X	 * just pointing yyin at a new input file.
X	 */
X#define YY_BUFFER_EOF_PENDING 2
X	};
X
Xstatic YY_BUFFER_STATE yy_current_buffer = 0;
X
X/* We provide macros for accessing buffer states in case in the
X * future we want to put the buffer states in a more general
X * "scanner state".
X */
X#define YY_CURRENT_BUFFER yy_current_buffer
X
X
X/* yy_hold_char holds the character lost when yytext is formed. */
Xstatic char yy_hold_char;
X
Xstatic int yy_n_chars;		/* number of characters read into yy_ch_buf */
X
X
Xint yyleng;
X
X/* Points to current character in buffer. */
Xstatic char *yy_c_buf_p = (char *) 0;
Xstatic int yy_init = 1;		/* whether we need to initialize */
Xstatic int yy_start = 0;	/* start state number */
X
X/* Flag which is used to allow yywrap()'s to do buffer switches
X * instead of setting up a fresh yyin.  A bit of a hack ...
X */
Xstatic int yy_did_buffer_switch_on_eof;
X
Xstatic void yyunput YY_PROTO(( int c, char *buf_ptr ));
Xvoid yyrestart YY_PROTO(( FILE *input_file ));
Xvoid yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
Xvoid yy_load_buffer_state YY_PROTO(( void ));
XYY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
Xvoid yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
Xvoid yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
X
Xstatic int yy_start_stack_ptr = 0;
Xstatic int yy_start_stack_depth = 0;
Xstatic int *yy_start_stack = 0;
Xstatic void yy_push_state YY_PROTO(( int new_state ));
Xstatic void yy_pop_state YY_PROTO(( void ));
Xstatic int yy_top_state YY_PROTO(( void ));
X
Xstatic void *yy_flex_alloc YY_PROTO(( unsigned int ));
Xstatic void *yy_flex_realloc YY_PROTO(( void *, unsigned int ));
Xstatic void yy_flex_free YY_PROTO(( void * ));
X
X#define yy_new_buffer yy_create_buffer
X
X#define INITIAL 0
Xtypedef unsigned char YY_CHAR;
Xtypedef int yy_state_type;
XFILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
Xextern char *yytext;
X#define yytext_ptr yytext
X
X#ifndef yytext_ptr
Xstatic void yy_flex_strncpy YY_PROTO(( char *, const char *, int ));
X#endif
X
X#ifdef __cplusplus
Xstatic int yyinput YY_PROTO(( void ));
X#else
Xstatic int input YY_PROTO(( void ));
X#endif
X
Xstatic yy_state_type yy_get_previous_state YY_PROTO(( void ));
Xstatic yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
Xstatic int yy_get_next_buffer YY_PROTO(( void ));
Xstatic void yy_fatal_error YY_PROTO(( const char msg[] ));
X
X/* Done after the current pattern has been matched and before the
X * corresponding action - sets up yytext.
X */
X#define YY_DO_BEFORE_ACTION \
X	yytext_ptr = yy_bp; \
X	yyleng = yy_cp - yy_bp; \
X	yy_hold_char = *yy_cp; \
X	*yy_cp = '\0'; \
X	yy_c_buf_p = yy_cp;
X
X#define YY_END_OF_BUFFER 113
Xstatic const short int yy_accept[324] =
X    {   0,
X        0,    0,  113,  111,  108,  110,   74,   86,  111,   80,
X       73,  111,   68,   69,   78,   77,   65,   76,   72,   79,
X       36,   36,   66,   62,   81,   67,   82,   85,   33,   70,
X      106,   71,   83,   33,   33,   33,   33,   33,   33,   33,
X       33,   33,   33,   33,   33,   33,   33,   33,   63,   84,
X       64,   75,  108,  108,   61,    0,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,   47,   56,   48,    0,    0,
X       45,   53,   43,   54,   44,   55,   39,  107,   46,   40,
X       35,    0,   36,    0,   36,   52,   58,   60,   59,   51,
X       33,   49,   33,   33,   33,   33,   33,   33,    8,   33,
X
X       33,   33,   33,   33,   33,   16,   33,   33,   33,   33,
X       33,   33,   33,   33,   33,   33,   33,   50,   57,  108,
X      109,    0,    0,    0,    0,    0,    0,   94,    0,    0,
X        0,    0,    0,    0,    0,   37,    0,   39,   39,    0,
X       40,   35,    0,   38,   34,   42,   41,   33,   33,   33,
X       33,   33,   33,   33,   33,   33,   33,   33,   14,   33,
X       17,   33,   33,   33,   33,   33,   33,   33,   33,   33,
X       33,   33,   33,   33,   33,   33,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,    0,    0,   39,    0,   39,    0,   40,   38,
X
X       34,    1,   33,    3,    4,   33,   33,   33,   33,   10,
X       11,   33,   33,   15,   18,   33,   33,   33,   33,   33,
X       33,   33,   33,   33,   33,   33,   30,   33,   33,    0,
X        0,   97,   98,    0,    0,    0,    0,    0,    0,    0,
X       90,    0,  102,    0,    0,    0,    0,   39,    2,    5,
X       33,   33,   33,   33,   13,   33,   33,   21,   33,   33,
X       33,   33,   33,   33,   28,   33,   33,   32,    0,    0,
X       93,   91,  103,   95,    0,    0,    0,    0,    0,   88,
X        0,   33,   33,    9,   12,   33,   20,   22,   23,   24,
X       25,   26,   33,   33,   33,  104,   87,   96,  100,    0,
X
X       92,    0,    0,   33,    7,   33,   27,   33,   33,   89,
X        0,  101,    6,   19,   29,   31,    0,  105,    0,    0,
X        0,   99,    0
X    } ;
X
Xstatic const int yy_ec[256] =
X    {   0,
X        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
X        2,    2,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    2,    4,    5,    6,    1,    7,    8,    9,   10,
X       11,   12,   13,   14,   15,   16,   17,   18,   19,   19,
X       19,   19,   19,   19,   19,   19,   19,   20,   21,   22,
X       23,   24,   25,    1,   26,   26,   26,   26,   27,   28,
X       29,   29,   29,   29,   29,   30,   29,   29,   29,   29,
X       29,   29,   29,   29,   31,   29,   29,   32,   29,   29,
X       33,   34,   35,   36,   37,    1,   38,   39,   40,   41,
X
X       42,   43,   44,   45,   46,   29,   47,   48,   49,   50,
X       51,   52,   29,   53,   54,   55,   56,   57,   58,   59,
X       60,   61,   62,   63,   64,   65,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1
X    } ;
X
Xstatic const int yy_meta[66] =
X    {   0,
X        1,    1,    2,    1,    1,    1,    1,    1,    2,    1,
X        1,    1,    1,    1,    1,    1,    1,    3,    3,    1,
X        1,    1,    1,    1,    1,    3,    3,    3,    4,    4,
X        4,    4,    1,    1,    1,    1,    4,    3,    3,    3,
X        3,    3,    3,    4,    4,    4,    4,    4,    4,    4,
X        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
X        4,    1,    1,    1,    1
X    } ;
X
Xstatic const short int yy_base[327] =
X    {   0,
X        0,  445,  446,  448,  443,  448,  421,  448,   64,  420,
X       59,  408,  448,  448,  418,   55,  448,   56,   51,   60,
X      107,   73,  448,  448,   51,  417,   52,  448,    0,  448,
X      448,  448,  416,  382,  384,   39,   43,   38,   45,  385,
X       58,  384,  392,   85,  373,  382,  380,  385,  448,   64,
X      448,  448,   96,  427,  448,    0,  374,  385,   61,   92,
X      380,  372,  384,  373,  384,  448,  448,  448,   98,  412,
X      448,  448,  448,  448,  448,  448,  126,  448,  448,  143,
X      162,  133,  127,    0,  178,  397,  448,  448,  448,  396,
X        0,  448,  363,  375,  362,  377,  364,  370,  356,  357,
X
X      354,  354,  357,  354,  351,    0,  350,  354,   69,  352,
X       75,  112,  356,  349,  113,  131,  354,  448,  448,  185,
X      448,  345,  355,  118,  356,  343,  353,  149,  342,  353,
X      342,  353,  350,  157,  336,  448,  188,  448,  194,  210,
X      448,  184,  198,  220,  213,  448,  448,  337,  349,  344,
X      332,  176,  346,  344,  340,  332,  338,  341,    0,  327,
X        0,  333,  330,  319,  321,  323,  330,  316,  314,  314,
X      326,  316,  320,  324,  326,  315,  320,  315,  317,  317,
X      312,  306,  306,  313,  313,  302,  304,  309,  306,  295,
X      294,  305,  296,  227,  234,  236,  448,  238,  248,  448,
X
X      241,    0,  298,    0,    0,  289,  297,  286,  293,    0,
X        0,  287,  284,    0,    0,  284,  284,  281,  293,  283,
X      287,  292,  291,  289,  279,  284,    0,  272,  284,  272,
X      274,  448,  448,  280,  269,  266,  277,  277,  265,  261,
X      448,  267,  448,  261,  271,  267,  240,  255,    0,    0,
X      262,  263,  268,  255,    0,  247,  251,    0,  259,  256,
X      255,  239,  248,  250,    0,  240,  242,    0,  232,  244,
X      448,  448,  448,  448,  241,  226,  239,  241,  233,  448,
X      220,  209,  205,    0,    0,  205,    0,    0,    0,    0,
X        0,    0,  198,  193,  185,  448,  448,  448,  448,  185,
X
X      448,  166,  167,  160,    0,  147,    0,  143,  140,  139,
X      105,  448,    0,    0,    0,    0,   97,  448,   86,   58,
X       40,  448,  448,  303,  305,   78
X    } ;
X
Xstatic const short int yy_def[327] =
X    {   0,
X      323,    1,  323,  323,  323,  323,  323,  323,  323,  323,
X      323,  324,  323,  323,  323,  323,  323,  323,  323,  323,
X      323,  323,  323,  323,  323,  323,  323,  323,  325,  323,
X      323,  323,  323,  325,  325,  325,  325,  325,  325,  325,
X      325,  325,  325,  325,  325,  325,  325,  325,  323,  323,
X      323,  323,  323,  323,  323,    9,  323,  323,  323,  323,
X      323,  323,  323,  323,  323,  323,  323,  323,  324,  324,
X      323,  323,  323,  323,  323,  323,  323,  323,  323,  323,
X      323,  323,  323,  326,  323,  323,  323,  323,  323,  323,
X      325,  323,  325,  325,  325,  325,  325,  325,  325,  325,
X
X      325,  325,  325,  325,  325,  325,  325,  325,  325,  325,
X      325,  325,  325,  325,  325,  325,  325,  323,  323,  323,
X      323,  323,  323,  323,  323,  323,  323,  323,  323,  323,
X      323,  323,  323,  323,  323,  323,  323,  323,  323,  323,
X      323,  323,  323,  323,  326,  323,  323,  325,  325,  325,
X      325,  325,  325,  325,  325,  325,  325,  325,  325,  325,
X      325,  325,  325,  325,  325,  325,  325,  325,  325,  325,
X      325,  325,  325,  325,  325,  325,  323,  323,  323,  323,
X      323,  323,  323,  323,  323,  323,  323,  323,  323,  323,
X      323,  323,  323,  323,  323,  323,  323,  323,  323,  323,
X
X      323,  325,  325,  325,  325,  325,  325,  325,  325,  325,
X      325,  325,  325,  325,  325,  325,  325,  325,  325,  325,
X      325,  325,  325,  325,  325,  325,  325,  325,  325,  323,
X      323,  323,  323,  323,  323,  323,  323,  323,  323,  323,
X      323,  323,  323,  323,  323,  323,  323,  323,  325,  325,
X      325,  325,  325,  325,  325,  325,  325,  325,  325,  325,
X      325,  325,  325,  325,  325,  325,  325,  325,  323,  323,
X      323,  323,  323,  323,  323,  323,  323,  323,  323,  323,
X      323,  325,  325,  325,  325,  325,  325,  325,  325,  325,
X      325,  325,  325,  325,  325,  323,  323,  323,  323,  323,
X
X      323,  323,  323,  325,  325,  325,  325,  325,  325,  323,
X      323,  323,  325,  325,  325,  325,  323,  323,  323,  323,
X      323,  323,    0,  323,  323,  323
X    } ;
X
Xstatic const short int yy_nxt[514] =
X    {   0,
X        4,    5,    6,    7,    8,    9,   10,   11,   12,   13,
X       14,   15,   16,   17,   18,   19,   20,   21,   22,   23,
X       24,   25,   26,   27,   28,   29,   29,   29,   29,   29,
X       29,   29,   30,   31,   32,   33,   29,   34,   35,   36,
X       37,   38,   39,   40,   29,   41,   29,   42,   29,   29,
X       29,   29,   43,   44,   45,   46,   47,   48,   29,   29,
X       29,   49,   50,   51,   52,   56,   67,   72,   77,   77,
X       74,   78,   86,   87,   89,   90,   95,   73,   75,   76,
X      145,   68,   79,   96,   98,  100,  118,  101,   80,   97,
X       85,   85,  103,   99,  322,  104,  102,  120,  121,   82,
X
X      106,   57,   83,   83,   58,   59,  136,  107,  124,   60,
X      125,   61,  163,  126,   82,   62,  321,   63,  166,   64,
X       83,   65,   80,  164,   81,   81,  119,  320,   83,  110,
X      111,   70,  127,   82,  128,  167,   83,   83,   84,  112,
X      129,  130,  113,   77,   77,  143,  319,  143,   82,  168,
X      144,  144,  137,  138,   83,  138,   83,   83,  172,  318,
X      139,  139,   83,  179,  169,   84,  173,  137,  138,  140,
X      141,  180,  141,  138,   83,  317,  174,   80,  175,   81,
X       81,  316,   83,  315,  140,  141,  120,  121,   82,  184,
X      141,  142,  142,   80,  191,   85,   85,  192,  185,  314,
X
X      194,  313,  194,   82,   82,  195,  195,   83,   83,  142,
X      312,  139,  139,  142,  142,  144,  144,  142,  311,   82,
X      196,  197,  198,  197,  198,   83,  310,  199,  199,  206,
X      207,  142,  309,   83,  308,  196,  197,  144,  144,  142,
X      307,  197,  201,  201,  195,  195,  306,  200,  247,  200,
X      247,  195,  195,  248,  248,  199,  199,  248,  248,  305,
X      201,  138,  200,  138,  304,  199,  199,  200,  201,  303,
X      201,  201,  248,  248,  302,  141,  138,  141,  301,  300,
X      299,  138,  197,  298,  197,  297,  296,  295,  201,  294,
X      141,  293,  292,  291,  290,  141,  201,  197,  289,  288,
X
X      287,  286,  197,   69,  285,   69,   69,   91,   91,  284,
X      283,  282,  281,  280,  279,  278,  277,  276,  275,  274,
X      273,  272,  271,  270,  269,  268,  267,  266,  265,  264,
X      263,  262,  261,  260,  259,  258,  257,  256,  255,  254,
X      253,  252,  251,  250,  249,  246,  245,  244,  243,  242,
X      241,  240,  239,  238,  237,  236,  235,  234,  233,  232,
X      231,  230,  229,  228,  227,  226,  225,  224,  223,  222,
X      221,  220,  219,  218,  217,  216,  215,  214,  213,  212,
X      211,  210,  209,  208,  205,  204,  203,  202,  193,  190,
X      189,  188,  187,  186,  183,  182,  181,  178,  177,  176,
X
X      171,  170,  165,  162,  161,  160,  159,  158,  157,  156,
X      155,  154,  153,  152,  151,  150,  149,  148,  147,  146,
X       69,  135,  134,  133,  132,  131,  123,  122,   54,  117,
X      116,  115,  114,  109,  108,  105,   94,   93,   92,   88,
X       71,   70,   66,   55,   54,  323,   53,    3,  323,  323,
X      323,  323,  323,  323,  323,  323,  323,  323,  323,  323,
X      323,  323,  323,  323,  323,  323,  323,  323,  323,  323,
X      323,  323,  323,  323,  323,  323,  323,  323,  323,  323,
X      323,  323,  323,  323,  323,  323,  323,  323,  323,  323,
X      323,  323,  323,  323,  323,  323,  323,  323,  323,  323,
X
X      323,  323,  323,  323,  323,  323,  323,  323,  323,  323,
X      323,  323,  323
X    } ;
X
Xstatic const short int yy_chk[514] =
X    {   0,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    9,   11,   16,   19,   19,
X       18,   20,   25,   25,   27,   27,   36,   16,   18,   18,
X      326,   11,   20,   36,   37,   38,   50,   38,   22,   36,
X       22,   22,   39,   37,  321,   39,   38,   53,   53,   22,
X
X       41,    9,   22,   22,    9,    9,   69,   41,   59,    9,
X       59,    9,  109,   59,   22,    9,  320,    9,  111,    9,
X       22,    9,   21,  109,   21,   21,   50,  319,   22,   44,
X       44,   69,   60,   21,   60,  111,   21,   21,   21,   44,
X       60,   60,   44,   77,   77,   82,  317,   82,   21,  112,
X       82,   82,   77,   77,   21,   77,   83,   83,  115,  311,
X       80,   80,   21,  124,  112,   21,  115,   77,   77,   80,
X       80,  124,   80,   77,   83,  310,  116,   81,  116,   81,
X       81,  309,   83,  308,   80,   80,  120,  120,   81,  128,
X       80,   81,   81,   85,  134,   85,   85,  134,  128,  306,
X
X      137,  304,  137,   81,   85,  137,  137,   85,   85,   81,
X      303,  139,  139,  142,  142,  143,  143,   81,  302,   85,
X      139,  139,  140,  139,  140,   85,  300,  140,  140,  152,
X      152,  142,  295,   85,  294,  139,  139,  144,  144,  142,
X      293,  139,  145,  145,  194,  194,  286,  144,  196,  144,
X      196,  195,  195,  196,  196,  198,  198,  247,  247,  283,
X      145,  195,  144,  195,  282,  199,  199,  144,  145,  281,
X      201,  201,  248,  248,  279,  199,  195,  199,  278,  277,
X      276,  195,  248,  275,  248,  270,  269,  267,  201,  266,
X      199,  264,  263,  262,  261,  199,  201,  248,  260,  259,
X
X      257,  256,  248,  324,  254,  324,  324,  325,  325,  253,
X      252,  251,  246,  245,  244,  242,  240,  239,  238,  237,
X      236,  235,  234,  231,  230,  229,  228,  226,  225,  224,
X      223,  222,  221,  220,  219,  218,  217,  216,  213,  212,
X      209,  208,  207,  206,  203,  193,  192,  191,  190,  189,
X      188,  187,  186,  185,  184,  183,  182,  181,  180,  179,
X      178,  177,  176,  175,  174,  173,  172,  171,  170,  169,
X      168,  167,  166,  165,  164,  163,  162,  160,  158,  157,
X      156,  155,  154,  153,  151,  150,  149,  148,  135,  133,
X      132,  131,  130,  129,  127,  126,  125,  123,  122,  117,
X
X      114,  113,  110,  108,  107,  105,  104,  103,  102,  101,
X      100,   99,   98,   97,   96,   95,   94,   93,   90,   86,
X       70,   65,   64,   63,   62,   61,   58,   57,   54,   48,
X       47,   46,   45,   43,   42,   40,   35,   34,   33,   26,
X       15,   12,   10,    7,    5,    3,    2,  323,  323,  323,
X      323,  323,  323,  323,  323,  323,  323,  323,  323,  323,
X      323,  323,  323,  323,  323,  323,  323,  323,  323,  323,
X      323,  323,  323,  323,  323,  323,  323,  323,  323,  323,
X      323,  323,  323,  323,  323,  323,  323,  323,  323,  323,
X      323,  323,  323,  323,  323,  323,  323,  323,  323,  323,
X
X      323,  323,  323,  323,  323,  323,  323,  323,  323,  323,
X      323,  323,  323
X    } ;
X
Xstatic yy_state_type yy_last_accepting_state;
Xstatic char *yy_last_accepting_cpos;
X
X/* The intent behind this definition is that it'll catch
X * any uses of REJECT which flex missed.
X */
X#define REJECT reject_used_but_not_detected
X#define yymore() yymore_used_but_not_detected
X#define YY_MORE_ADJ 0
Xchar *yytext;
X# line 1 "scan.l"
X# line 12 "scan.l"
X
X/* $Id: scan.l,v 1.12 1994/10/11 15:45:22 lott Exp lott $
X *
X * csize, a program to measure the size of C source files.
X * Copyright (C) 1994 Christopher Lott <lott@informatik.uni-kl.de>
X * FB Informatik - Bau 57 / Universitaet KL / D--67653 Kaiserslautern / Germany
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation.  See the file COPYING for more details.
X *
X * This file holds the source used by flex to generate the scanner for C.
X * SEE THE FILE "INSTALL" FOR THE REQUIRED FLEX VERSION.  Sorry to
X * shout, but different versions of flex exhibit different behavior.  
X *
X * Why flex?  Because lex complains about this file as follows:
X *     "scan.l", line xxx: (Error) Too many right contexts
X * If you simply remove the first token ("auto"), then lex dumps core
X * on my machine.  Neither behavior is acceptable and I refuse to code
X * around bugs in lex when flex is available, reliable, and free.
X *
X */
X
X#include <stdio.h>
X#include <scan.h>
X#include <csize.h>
X
X/* variables supplied by flex
X *
X */
X
Xextern int yyleng;
Xextern char *yytext;
Xextern FILE *yyin;
X
X/* global variables
X * variables beginning with C_ are referenced in main and
X * Echo is set in main; all appear in csize.h
X *
X */
X
Xint  Echo, 
X     Lex_errors;
X
Xlong C_newlines,           /* incremented at the *end* of a line */
X     C_blank_lines,
X     C_lines_w_comments,   
X     C_nb_nc_lines,        /* incremented when first nbnc is seen */
X     C_semicolons,
X     C_pp_directives;
X
X/*
X * variables used only in this file
X */
X
Xstatic char *Filename;
Xstatic int Column;
Xstatic long prev_line_with_text;
Xstatic long prev_line_with_comment;
X
X/*
X * functions defined and used only in this file
X */
X
Xstatic int check_type _((void));
Xstatic void count_nb_nc_lines _((void));
Xstatic void count _((void));
Xstatic void semicolon _((void));
Xstatic void string_lit _((void));
Xstatic void count_line_w_comment _((void));
Xstatic void comment _((int));
Xstatic void pp_dir _((void));
Xstatic void count_ws _((void));
Xstatic void whitespace_line _((void));
Xstatic void newline _((void));
Xstatic void scan_error _((char *));
Xstatic void bad_char _((void));
X
X
X/* Macros after this point can all be overridden by user definitions in
X * section 1.
X */
X
X#ifdef YY_MALLOC_DECL
XYY_MALLOC_DECL
X#else
X#if __STDC__
X#ifndef __cplusplus
X#include <stdlib.h>
X#endif
X#else
X/* Just try to get by without declaring the routines.  This will fail
X * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
X * or sizeof(void*) != sizeof(int).
X */
X#endif
X#endif
X
X/* Amount of stuff to slurp up with each read. */
X#ifndef YY_READ_BUF_SIZE
X#define YY_READ_BUF_SIZE 8192
X#endif
X
X/* Copy whatever the last rule matched to the standard output. */
X
X#ifndef ECHO
X/* This used to be an fputs(), but since the string might contain NUL's,
X * we now use fwrite().
X */
X#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
X#endif
X
X/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
X * is returned in "result".
X */
X#ifndef YY_INPUT
X#define YY_INPUT(buf,result,max_size) \
X	if ( yy_current_buffer->yy_is_interactive ) \
X		{ \
X		int c = getc( yyin ); \
X		result = c == EOF ? 0 : 1; \
X		buf[0] = (char) c; \
X		} \
X	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
X		  && ferror( yyin ) ) \
X		YY_FATAL_ERROR( "input in flex scanner failed" );
X#endif
X
X/* No semi-colon after return; correct usage is to write "yyterminate();" -
X * we don't want an extra ';' after the "return" because that will cause
X * some compilers to complain about unreachable statements.
X */
X#ifndef yyterminate
X#define yyterminate() return YY_NULL
X#endif
X
X/* Number of entries by which start-condition stack grows. */
X#ifndef YY_START_STACK_INCR
X#define YY_START_STACK_INCR 25
X#endif
X
X/* Report a fatal error. */
X#ifndef YY_FATAL_ERROR
X#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
X#endif
X
X/* Default declaration of generated scanner - a define so the user can
X * easily add parameters.
X */
X#ifndef YY_DECL
X#define YY_DECL int yylex YY_PROTO(( void ))
X#endif
X
X/* Code executed at the beginning of each rule, after yytext and yyleng
X * have been set up.
X */
X#ifndef YY_USER_ACTION
X#define YY_USER_ACTION
X#endif
X
X/* Code executed at the end of each rule. */
X#ifndef YY_BREAK
X#define YY_BREAK break;
X#endif
X
XYY_DECL
X	{
X	register yy_state_type yy_current_state;
X	register char *yy_cp, *yy_bp;
X	register int yy_act;
X
X# line 92 "scan.l"
X
X
X
X	if ( yy_init )
X		{
X#ifdef YY_USER_INIT
X		YY_USER_INIT;
X#endif
X
X		if ( ! yy_start )
X			yy_start = 1;	/* first start state */
X
X		if ( ! yyin )
X			yyin = stdin;
X
X		if ( ! yyout )
X			yyout = stdout;
X
X		if ( yy_current_buffer )
X			yy_init_buffer( yy_current_buffer, yyin );
X		else
X			yy_current_buffer =
X				yy_create_buffer( yyin, YY_BUF_SIZE );
X
X		yy_load_buffer_state();
X
X		yy_init = 0;
X		}
X
X	while ( 1 )		/* loops until end-of-file is reached */
X		{
X		yy_cp = yy_c_buf_p;
X
X		/* Support of yytext. */
X		*yy_cp = yy_hold_char;
X
X		/* yy_bp points to the position in yy_ch_buf of the start of
X		 * the current run.
X		 */
X		yy_bp = yy_cp;
X
X		yy_current_state = yy_start;
X		if ( yy_bp[-1] == '\n' )
X			++yy_current_state;
Xyy_match:
X		do
X			{
X			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
X			if ( yy_accept[yy_current_state] )
X				{
X				yy_last_accepting_state = yy_current_state;
X				yy_last_accepting_cpos = yy_cp;
X				}
X			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
X				{
X				yy_current_state = (int) yy_def[yy_current_state];
X				if ( yy_current_state >= 324 )
X					yy_c = yy_meta[(unsigned int) yy_c];
X				}
X			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
X			++yy_cp;
X			}
X		while ( yy_base[yy_current_state] != 448 );
X
Xyy_find_action:
X		yy_act = yy_accept[yy_current_state];
X
X		YY_DO_BEFORE_ACTION;
X
X
Xdo_action:	/* This label is used only to access EOF actions. */
X
X
X		switch ( yy_act )
X	{ /* beginning of action switch */
X			case 0: /* must back up */
X			/* undo the effects of YY_DO_BEFORE_ACTION */
X			*yy_cp = yy_hold_char;
X			yy_cp = yy_last_accepting_cpos;
X			yy_current_state = yy_last_accepting_state;
X			goto yy_find_action;
X
Xcase 1:
XYY_USER_ACTION
X# line 94 "scan.l"
X{ count(); return(AUTO);     }
X	YY_BREAK
Xcase 2:
XYY_USER_ACTION
X# line 95 "scan.l"
X{ count(); return(BREAK);    }
X	YY_BREAK
Xcase 3:
XYY_USER_ACTION
X# line 96 "scan.l"
X{ count(); return(CASE);     }
X	YY_BREAK
Xcase 4:
XYY_USER_ACTION
X# line 97 "scan.l"
X{ count(); return(CHAR);     }
X	YY_BREAK
Xcase 5:
XYY_USER_ACTION
X# line 98 "scan.l"
X{ count(); return(CONST);    }
X	YY_BREAK
Xcase 6:
XYY_USER_ACTION
X# line 99 "scan.l"
X{ count(); return(CONTINUE); }
X	YY_BREAK
Xcase 7:
XYY_USER_ACTION
X# line 100 "scan.l"
X{ count(); return(DEFAULT);  }
X	YY_BREAK
Xcase 8:
XYY_USER_ACTION
X# line 101 "scan.l"
X{ count(); return(DO);       }
X	YY_BREAK
Xcase 9:
XYY_USER_ACTION
X# line 102 "scan.l"
X{ count(); return(DOUBLE);   }
X	YY_BREAK
Xcase 10:
XYY_USER_ACTION
X# line 103 "scan.l"
X{ count(); return(ELSE);     }
X	YY_BREAK
Xcase 11:
XYY_USER_ACTION
X# line 104 "scan.l"
X{ count(); return(ENUM);     }
X	YY_BREAK
Xcase 12:
XYY_USER_ACTION
X# line 105 "scan.l"
X{ count(); return(EXTERN);   }
X	YY_BREAK
Xcase 13:
XYY_USER_ACTION
X# line 106 "scan.l"
X{ count(); return(FLOAT);    }
X	YY_BREAK
Xcase 14:
XYY_USER_ACTION
X# line 107 "scan.l"
X{ count(); return(FOR);      }
X	YY_BREAK
Xcase 15:
XYY_USER_ACTION
X# line 108 "scan.l"
X{ count(); return(GOTO);     }
X	YY_BREAK
Xcase 16:
XYY_USER_ACTION
X# line 109 "scan.l"
X{ count(); return(IF);       }
X	YY_BREAK
Xcase 17:
XYY_USER_ACTION
X# line 110 "scan.l"
X{ count(); return(INT);      }
X	YY_BREAK
Xcase 18:
XYY_USER_ACTION
X# line 111 "scan.l"
X{ count(); return(LONG);     }
X	YY_BREAK
Xcase 19:
XYY_USER_ACTION
X# line 112 "scan.l"
X{ count(); return(REGISTER); }
X	YY_BREAK
Xcase 20:
XYY_USER_ACTION
X# line 113 "scan.l"
X{ count(); return(RETURN);   }
X	YY_BREAK
Xcase 21:
XYY_USER_ACTION
X# line 114 "scan.l"
X{ count(); return(SHORT);    }
X	YY_BREAK
Xcase 22:
XYY_USER_ACTION
X# line 115 "scan.l"
X{ count(); return(SIGNED);   }
X	YY_BREAK
Xcase 23:
XYY_USER_ACTION
X# line 116 "scan.l"
X{ count(); return(SIZEOF);   }
X	YY_BREAK
Xcase 24:
XYY_USER_ACTION
X# line 117 "scan.l"
X{ count(); return(STATIC);   }
X	YY_BREAK
Xcase 25:
XYY_USER_ACTION
X# line 118 "scan.l"
X{ count(); return(STRUCT);   }
X	YY_BREAK
Xcase 26:
XYY_USER_ACTION
X# line 119 "scan.l"
X{ count(); return(SWITCH);   }
X	YY_BREAK
Xcase 27:
XYY_USER_ACTION
X# line 120 "scan.l"
X{ count(); return(TYPEDEF);  }
X	YY_BREAK
Xcase 28:
XYY_USER_ACTION
X# line 121 "scan.l"
X{ count(); return(UNION);    }
X	YY_BREAK
Xcase 29:
XYY_USER_ACTION
X# line 122 "scan.l"
X{ count(); return(UNSIGNED); }
X	YY_BREAK
Xcase 30:
XYY_USER_ACTION
X# line 123 "scan.l"
X{ count(); return(VOID);     }
X	YY_BREAK
Xcase 31:
XYY_USER_ACTION
X# line 124 "scan.l"
X{ count(); return(VOLATILE); }
X	YY_BREAK
Xcase 32:
XYY_USER_ACTION
X# line 125 "scan.l"
X{ count(); return(WHILE);    }
X	YY_BREAK
Xcase 33:
XYY_USER_ACTION
X# line 127 "scan.l"
X{ count(); return(check_type()); }
X	YY_BREAK
Xcase 34:
XYY_USER_ACTION
X# line 129 "scan.l"
X{ count(); return(CONSTANT); }
X	YY_BREAK
Xcase 35:
XYY_USER_ACTION
X# line 130 "scan.l"
X{ count(); return(CONSTANT); }
X	YY_BREAK
Xcase 36:
XYY_USER_ACTION
X# line 131 "scan.l"
X{ count(); return(CONSTANT); }
X	YY_BREAK
Xcase 37:
XYY_USER_ACTION
X# line 132 "scan.l"
X{ count(); return(CONSTANT); }
X	YY_BREAK
Xcase 38:
XYY_USER_ACTION
X# line 134 "scan.l"
X{ count(); return(CONSTANT); }
X	YY_BREAK
Xcase 39:
XYY_USER_ACTION
X# line 135 "scan.l"
X{ count(); return(CONSTANT); }
X	YY_BREAK
Xcase 40:
XYY_USER_ACTION
X# line 136 "scan.l"
X{ count(); return(CONSTANT); }
X	YY_BREAK
Xcase 41:
XYY_USER_ACTION
X# line 138 "scan.l"
X{ count(); return(RIGHT_ASSIGN); }
X	YY_BREAK
Xcase 42:
XYY_USER_ACTION
X# line 139 "scan.l"
X{ count(); return(LEFT_ASSIGN); }
X	YY_BREAK
Xcase 43:
XYY_USER_ACTION
X# line 140 "scan.l"
X{ count(); return(ADD_ASSIGN); }
X	YY_BREAK
Xcase 44:
XYY_USER_ACTION
X# line 141 "scan.l"
X{ count(); return(SUB_ASSIGN); }
X	YY_BREAK
Xcase 45:
XYY_USER_ACTION
X# line 142 "scan.l"
X{ count(); return(MUL_ASSIGN); }
X	YY_BREAK
Xcase 46:
XYY_USER_ACTION
X# line 143 "scan.l"
X{ count(); return(DIV_ASSIGN); }
X	YY_BREAK
Xcase 47:
XYY_USER_ACTION
X# line 144 "scan.l"
X{ count(); return(MOD_ASSIGN); }
X	YY_BREAK
Xcase 48:
XYY_USER_ACTION
X# line 145 "scan.l"
X{ count(); return(AND_ASSIGN); }
X	YY_BREAK
Xcase 49:
XYY_USER_ACTION
X# line 146 "scan.l"
X{ count(); return(XOR_ASSIGN); }
X	YY_BREAK
Xcase 50:
XYY_USER_ACTION
X# line 147 "scan.l"
X{ count(); return(OR_ASSIGN); }
X	YY_BREAK
Xcase 51:
XYY_USER_ACTION
X# line 148 "scan.l"
X{ count(); return(RIGHT_OP); }
X	YY_BREAK
Xcase 52:
XYY_USER_ACTION
X# line 149 "scan.l"
X{ count(); return(LEFT_OP); }
X	YY_BREAK
Xcase 53:
XYY_USER_ACTION
X# line 150 "scan.l"
X{ count(); return(INC_OP); }
X	YY_BREAK
Xcase 54:
XYY_USER_ACTION
X# line 151 "scan.l"
X{ count(); return(DEC_OP); }
X	YY_BREAK
Xcase 55:
XYY_USER_ACTION
X# line 152 "scan.l"
X{ count(); return(PTR_OP); }
X	YY_BREAK
Xcase 56:
XYY_USER_ACTION
X# line 153 "scan.l"
X{ count(); return(AND_OP); }
X	YY_BREAK
Xcase 57:
XYY_USER_ACTION
X# line 154 "scan.l"
X{ count(); return(OR_OP); }
X	YY_BREAK
Xcase 58:
XYY_USER_ACTION
X# line 155 "scan.l"
X{ count(); return(LE_OP); }
X	YY_BREAK
Xcase 59:
XYY_USER_ACTION
X# line 156 "scan.l"
X{ count(); return(GE_OP); }
X	YY_BREAK
Xcase 60:
XYY_USER_ACTION
X# line 157 "scan.l"
X{ count(); return(EQ_OP); }
X	YY_BREAK
Xcase 61:
XYY_USER_ACTION
X# line 158 "scan.l"
X{ count(); return(NE_OP); }
X	YY_BREAK
Xcase 62:
XYY_USER_ACTION
X# line 159 "scan.l"
X{ count(); semicolon(); return(';'); }
X	YY_BREAK
Xcase 63:
XYY_USER_ACTION
X# line 160 "scan.l"
X{ count(); return('{'); }
X	YY_BREAK
Xcase 64:
XYY_USER_ACTION
X# line 161 "scan.l"
X{ count(); return('}'); }
X	YY_BREAK
Xcase 65:
XYY_USER_ACTION
X# line 162 "scan.l"
X{ count(); return(','); }
X	YY_BREAK
Xcase 66:
XYY_USER_ACTION
X# line 163 "scan.l"
X{ count(); return(':'); }
X	YY_BREAK
Xcase 67:
XYY_USER_ACTION
X# line 164 "scan.l"
X{ count(); return('='); }
X	YY_BREAK
Xcase 68:
XYY_USER_ACTION
X# line 165 "scan.l"
X{ count(); return('('); }
X	YY_BREAK
Xcase 69:
XYY_USER_ACTION
X# line 166 "scan.l"
X{ count(); return(')'); }
X	YY_BREAK
Xcase 70:
XYY_USER_ACTION
X# line 167 "scan.l"
X{ count(); return('['); }
X	YY_BREAK
Xcase 71:
XYY_USER_ACTION
X# line 168 "scan.l"
X{ count(); return(']'); }
X	YY_BREAK
Xcase 72:
XYY_USER_ACTION
X# line 169 "scan.l"
X{ count(); return('.'); }
X	YY_BREAK
Xcase 73:
XYY_USER_ACTION
X# line 170 "scan.l"
X{ count(); return('&'); }
X	YY_BREAK
Xcase 74:
XYY_USER_ACTION
X# line 171 "scan.l"
X{ count(); return('!'); }
X	YY_BREAK
Xcase 75:
XYY_USER_ACTION
X# line 172 "scan.l"
X{ count(); return('~'); }
X	YY_BREAK
Xcase 76:
XYY_USER_ACTION
X# line 173 "scan.l"
X{ count(); return('-'); }
X	YY_BREAK
Xcase 77:
XYY_USER_ACTION
X# line 174 "scan.l"
X{ count(); return('+'); }
X	YY_BREAK
Xcase 78:
XYY_USER_ACTION
X# line 175 "scan.l"
X{ count(); return('*'); }
X	YY_BREAK
Xcase 79:
XYY_USER_ACTION
X# line 176 "scan.l"
X{ count(); return('/'); }
X	YY_BREAK
Xcase 80:
XYY_USER_ACTION
X# line 177 "scan.l"
X{ count(); return('%'); }
X	YY_BREAK
Xcase 81:
XYY_USER_ACTION
X# line 178 "scan.l"
X{ count(); return('<'); }
X	YY_BREAK
Xcase 82:
XYY_USER_ACTION
X# line 179 "scan.l"
X{ count(); return('>'); }
X	YY_BREAK
Xcase 83:
XYY_USER_ACTION
X# line 180 "scan.l"
X{ count(); return('^'); }
X	YY_BREAK
Xcase 84:
XYY_USER_ACTION
X# line 181 "scan.l"
X{ count(); return('|'); }
X	YY_BREAK
Xcase 85:
XYY_USER_ACTION
X# line 182 "scan.l"
X{ count(); return('?'); }
X	YY_BREAK
Xcase 86:
XYY_USER_ACTION
X# line 184 "scan.l"
X{ count(); string_lit(); return(STRING_LITERAL); }
X	YY_BREAK
Xcase 87:
XYY_USER_ACTION
X# line 186 "scan.l"
X{ count(); pp_dir(); /* from K&R 2/e p. 239 */ }
X	YY_BREAK
Xcase 88:
XYY_USER_ACTION
X# line 187 "scan.l"
X{ count(); pp_dir(); }
X	YY_BREAK
Xcase 89:
XYY_USER_ACTION
X# line 188 "scan.l"
X{ count(); pp_dir(); }
X	YY_BREAK
Xcase 90:
XYY_USER_ACTION
X# line 189 "scan.l"
X{ count(); pp_dir(); }
X	YY_BREAK
Xcase 91:
XYY_USER_ACTION
X# line 190 "scan.l"
X{ count(); pp_dir(); }
X	YY_BREAK
Xcase 92:
XYY_USER_ACTION
X# line 191 "scan.l"
X{ count(); pp_dir(); }
X	YY_BREAK
Xcase 93:
XYY_USER_ACTION
X# line 193 "scan.l"
X{ count(); pp_dir(); }
X	YY_BREAK
Xcase 94:
XYY_USER_ACTION
X# line 194 "scan.l"
X{ count(); pp_dir(); }
X	YY_BREAK
Xcase 95:
XYY_USER_ACTION
X# line 195 "scan.l"
X{ count(); pp_dir(); }
X	YY_BREAK
Xcase 96:
XYY_USER_ACTION
X# line 196 "scan.l"
X{ count(); pp_dir(); }
X	YY_BREAK
Xcase 97:
XYY_USER_ACTION
X# line 197 "scan.l"
X{ count(); pp_dir(); }
X	YY_BREAK
Xcase 98:
XYY_USER_ACTION
X# line 198 "scan.l"
X{ count(); pp_dir(); }
X	YY_BREAK
Xcase 99:
XYY_USER_ACTION
X# line 200 "scan.l"
X{ count(); pp_dir(); /* from GCC's cccp.c */ }
X	YY_BREAK
Xcase 100:
XYY_USER_ACTION
X# line 201 "scan.l"
X{ count(); pp_dir(); }
X	YY_BREAK
Xcase 101:
XYY_USER_ACTION
X# line 202 "scan.l"
X{ count(); pp_dir(); }
X	YY_BREAK
Xcase 102:
XYY_USER_ACTION
X# line 203 "scan.l"
X{ count(); pp_dir(); }
X	YY_BREAK
Xcase 103:
XYY_USER_ACTION
X# line 204 "scan.l"
X{ count(); pp_dir(); }
X	YY_BREAK
Xcase 104:
XYY_USER_ACTION
X# line 205 "scan.l"
X{ count(); pp_dir(); }
X	YY_BREAK
Xcase 105:
XYY_USER_ACTION
X# line 206 "scan.l"
X{ count(); pp_dir(); }
X	YY_BREAK
Xcase 106:
XYY_USER_ACTION
X# line 208 "scan.l"
X{ count(); /* backslash processing is weak */ }
X	YY_BREAK
Xcase 107:
XYY_USER_ACTION
X# line 210 "scan.l"
X{ comment(1); }
X	YY_BREAK
Xcase 108:
XYY_USER_ACTION
X# line 211 "scan.l"
X{ count_ws(); }
X	YY_BREAK
Xcase 109:
X*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
Xyy_c_buf_p = yy_cp -= 1;
XYY_DO_BEFORE_ACTION; /* set up yytext again */
XYY_USER_ACTION
X# line 212 "scan.l"
X{ whitespace_line(); }
X	YY_BREAK
Xcase 110:
XYY_USER_ACTION
X# line 213 "scan.l"
X{ newline(); }
X	YY_BREAK
Xcase 111:
XYY_USER_ACTION
X# line 214 "scan.l"
X{ bad_char(); }
X	YY_BREAK
Xcase 112:
XYY_USER_ACTION
X# line 216 "scan.l"
XECHO;
X	YY_BREAK
Xcase YY_STATE_EOF(INITIAL):
X	yyterminate();
X
X	case YY_END_OF_BUFFER:
X		{
X		/* Amount of text matched not including the EOB char. */
X		int yy_amount_of_matched_text = yy_cp - yytext_ptr - 1;
X
X		/* Undo the effects of YY_DO_BEFORE_ACTION. */
X		*yy_cp = yy_hold_char;
X
X		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
X			{
X			/* We're scanning a new file or input source.  It's
X			 * possible that this happened because the user
X			 * just pointed yyin at a new source and called
X			 * yylex().  If so, then we have to assure
X			 * consistency between yy_current_buffer and our
X			 * globals.  Here is the right place to do so, because
X			 * this is the first action (other than possibly a
X			 * back-up) that will match for the new input source.
X			 */
X			yy_n_chars = yy_current_buffer->yy_n_chars;
X			yy_current_buffer->yy_input_file = yyin;
X			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
X			}
X
X		/* Note that here we test for yy_c_buf_p "<=" to the position
X		 * of the first EOB in the buffer, since yy_c_buf_p will
X		 * already have been incremented past the NUL character
X		 * (since all states make transitions on EOB to the
X		 * end-of-buffer state).  Contrast this with the test
X		 * in input().
X		 */
X		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
X			{ /* This was really a NUL. */
X			yy_state_type yy_next_state;
X
X			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
X
X			yy_current_state = yy_get_previous_state();
X
X			/* Okay, we're now positioned to make the NUL
X			 * transition.  We couldn't have
X			 * yy_get_previous_state() go ahead and do it
X			 * for us because it doesn't know how to deal
X			 * with the possibility of jamming (and we don't
X			 * want to build jamming into it because then it
X			 * will run more slowly).
X			 */
X
X			yy_next_state = yy_try_NUL_trans( yy_current_state );
X
X			yy_bp = yytext_ptr + YY_MORE_ADJ;
X
X			if ( yy_next_state )
X				{
X				/* Consume the NUL. */
X				yy_cp = ++yy_c_buf_p;
X				yy_current_state = yy_next_state;
X				goto yy_match;
X				}
X
X			else
X				{
X							yy_cp = yy_c_buf_p;
X				goto yy_find_action;
X				}
X			}
X
X		else switch ( yy_get_next_buffer() )
X			{
X			case EOB_ACT_END_OF_FILE:
X				{
X				yy_did_buffer_switch_on_eof = 0;
X
X				if ( yywrap() )
X					{
X					/* Note: because we've taken care in
X					 * yy_get_next_buffer() to have set up
X					 * yytext, we can now set up
X					 * yy_c_buf_p so that if some total
X					 * hoser (like flex itself) wants to
X					 * call the scanner after we return the
X					 * YY_NULL, it'll still work - another
X					 * YY_NULL will get returned.
X					 */
X					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
X
X					yy_act = YY_STATE_EOF(YY_START);
X					goto do_action;
X					}
X
X				else
X					{
X					if ( ! yy_did_buffer_switch_on_eof )
X						YY_NEW_FILE;
X					}
X				break;
X				}
X
X			case EOB_ACT_CONTINUE_SCAN:
X				yy_c_buf_p =
X					yytext_ptr + yy_amount_of_matched_text;
X
X				yy_current_state = yy_get_previous_state();
X
X				yy_cp = yy_c_buf_p;
X				yy_bp = yytext_ptr + YY_MORE_ADJ;
X				goto yy_match;
X
X			case EOB_ACT_LAST_MATCH:
X				yy_c_buf_p =
X				&yy_current_buffer->yy_ch_buf[yy_n_chars];
X
X				yy_current_state = yy_get_previous_state();
X
X				yy_cp = yy_c_buf_p;
X				yy_bp = yytext_ptr + YY_MORE_ADJ;
X				goto yy_find_action;
X			}
X		break;
X		}
X
X	default:
X		YY_FATAL_ERROR(
X			"fatal flex scanner internal error--no action found" );
X	} /* end of action switch */
X		} /* end of scanning one token */
X	} /* end of yylex */
X
X
X/* yy_get_next_buffer - try to read in a new buffer
X *
X * Returns a code representing an action:
X *	EOB_ACT_LAST_MATCH -
X *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
X *	EOB_ACT_END_OF_FILE - end of file
X */
X
Xstatic int yy_get_next_buffer()
X	{
X	register char *dest = yy_current_buffer->yy_ch_buf;
X	register char *source = yytext_ptr - 1; /* copy prev. char, too */
X	register int number_to_move, i;
X	int ret_val;
X
X	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
X		YY_FATAL_ERROR(
X		"fatal flex scanner internal error--end of buffer missed" );
X
X	if ( yy_current_buffer->yy_fill_buffer == 0 )
X		{ /* Don't try to fill the buffer, so this is an EOF. */
X		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
X			{
X			/* We matched a singled characater, the EOB, so
X			 * treat this as a final EOF.
X			 */
X			return EOB_ACT_END_OF_FILE;
X			}
X
X		else
X			{
X			/* We matched some text prior to the EOB, first
X			 * process it.
X			 */
X			return EOB_ACT_LAST_MATCH;
X			}
X		}
X
X	/* Try to read more data. */
X
X	/* First move last chars to start of buffer. */
X	number_to_move = yy_c_buf_p - yytext_ptr;
X
X	for ( i = 0; i < number_to_move; ++i )
X		*(dest++) = *(source++);
X
X	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
X		/* don't do the read, it's not guaranteed to return an EOF,
X		 * just force an EOF
X		 */
X		yy_n_chars = 0;
X
X	else
X		{
X		int num_to_read =
X			yy_current_buffer->yy_buf_size - number_to_move - 1;
X
X		while ( num_to_read <= 0 )
X			{ /* Not enough room in the buffer - grow it. */
X#ifdef YY_USES_REJECT
X			YY_FATAL_ERROR(
X"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
X#else
X
X			/* just a shorter name for the current buffer */
X			YY_BUFFER_STATE b = yy_current_buffer;
X
X			int yy_c_buf_p_offset = yy_c_buf_p - b->yy_ch_buf;
X
X			b->yy_buf_size *= 2;
X			b->yy_ch_buf = (char *)
X				yy_flex_realloc( (void *) b->yy_ch_buf,
X						 b->yy_buf_size );
X
X			if ( ! b->yy_ch_buf )
X				YY_FATAL_ERROR(
X				"fatal error - scanner input buffer overflow" );
X
X			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
X
X			num_to_read = yy_current_buffer->yy_buf_size -
X						number_to_move - 1;
X#endif
X			}
X
X		if ( num_to_read > YY_READ_BUF_SIZE )
X			num_to_read = YY_READ_BUF_SIZE;
X
X		/* Read in more data. */
X		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
X			yy_n_chars, num_to_read );
X		}
X
X	if ( yy_n_chars == 0 )
X		{
X		if ( number_to_move - YY_MORE_ADJ == 1 )
X			{
X			ret_val = EOB_ACT_END_OF_FILE;
X			yyrestart( yyin );
X			}
X
X		else
X			{
X			ret_val = EOB_ACT_LAST_MATCH;
X			yy_current_buffer->yy_buffer_status =
X				YY_BUFFER_EOF_PENDING;
X			}
X		}
X
X	else
X		ret_val = EOB_ACT_CONTINUE_SCAN;
X
X	yy_n_chars += number_to_move;
X	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
X	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
X
X	/* yytext begins at the second character in yy_ch_buf; the first
X	 * character is the one which preceded it before reading in the latest
X	 * buffer; it needs to be kept around in case it's a newline, so
X	 * yy_get_previous_state() will have with '^' rules active.
X	 */
X
X	yytext_ptr = &yy_current_buffer->yy_ch_buf[1];
X
X	return ret_val;
X	}
X
X
X/* yy_get_previous_state - get the state just before the EOB char was reached */
X
Xstatic yy_state_type yy_get_previous_state()
X	{
X	register yy_state_type yy_current_state;
X	register char *yy_cp;
X
X	register char *yy_bp = yytext_ptr;
X
X	yy_current_state = yy_start;
X	if ( yy_bp[-1] == '\n' )
X		++yy_current_state;
X
X	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
X		{
X		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
X		if ( yy_accept[yy_current_state] )
X			{
X			yy_last_accepting_state = yy_current_state;
X			yy_last_accepting_cpos = yy_cp;
X			}
X		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
X			{
X			yy_current_state = (int) yy_def[yy_current_state];
X			if ( yy_current_state >= 324 )
X				yy_c = yy_meta[(unsigned int) yy_c];
X			}
X		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
X		}
X
X	return yy_current_state;
X	}
X
X
X/* yy_try_NUL_trans - try to make a transition on the NUL character
X *
X * synopsis
X *	next_state = yy_try_NUL_trans( current_state );
X */
X
X#ifdef YY_USE_PROTOS
Xstatic yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
X#else
Xstatic yy_state_type yy_try_NUL_trans( yy_current_state )
Xyy_state_type yy_current_state;
X#endif
X	{
X	register int yy_is_jam;
X	register char *yy_cp = yy_c_buf_p;
X
X	register YY_CHAR yy_c = 1;
X	if ( yy_accept[yy_current_state] )
X		{
X		yy_last_accepting_state = yy_current_state;
X		yy_last_accepting_cpos = yy_cp;
X		}
X	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
X		{
X		yy_current_state = (int) yy_def[yy_current_state];
X		if ( yy_current_state >= 324 )
X			yy_c = yy_meta[(unsigned int) yy_c];
X		}
X	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
X	yy_is_jam = (yy_current_state == 323);
X
X	return yy_is_jam ? 0 : yy_current_state;
X	}
X
X
X#ifdef YY_USE_PROTOS
Xstatic void yyunput( int c, register char *yy_bp )
X#else
Xstatic void yyunput( c, yy_bp )
Xint c;
Xregister char *yy_bp;
X#endif
X	{
X	register char *yy_cp = yy_c_buf_p;
X
X	/* undo effects of setting up yytext */
X	*yy_cp = yy_hold_char;
X
X	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
X		{ /* need to shift things up to make room */
X		/* +2 for EOB chars. */
X		register int number_to_move = yy_n_chars + 2;
X		register char *dest = &yy_current_buffer->yy_ch_buf[
X					yy_current_buffer->yy_buf_size + 2];
X		register char *source =
X				&yy_current_buffer->yy_ch_buf[number_to_move];
X
X		while ( source > yy_current_buffer->yy_ch_buf )
X			*--dest = *--source;
X
X		yy_cp += dest - source;
X		yy_bp += dest - source;
X		yy_n_chars = yy_current_buffer->yy_buf_size;
X
X		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
X			YY_FATAL_ERROR( "flex scanner push-back overflow" );
X		}
X
X	if ( yy_cp > yy_bp && yy_cp[-1] == '\n' )
X		yy_cp[-2] = '\n';
X
X	*--yy_cp = (char) c;
X
X
X	/* Note: the formal parameter *must* be called "yy_bp" for this
X	 * macro to now work correctly.
X	 */
X	YY_DO_BEFORE_ACTION; /* set up yytext again */
X	}
X
X
X#ifdef __cplusplus
Xstatic int yyinput()
X#else
Xstatic int input()
X#endif
X	{
X	int c;
X
X	*yy_c_buf_p = yy_hold_char;
X
X	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
X		{
X		/* yy_c_buf_p now points to the character we want to return.
X		 * If this occurs *before* the EOB characters, then it's a
X		 * valid NUL; if not, then we've hit the end of the buffer.
X		 */
X		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
X			/* This was really a NUL. */
X			*yy_c_buf_p = '\0';
X
X		else
X			{ /* need more input */
X			yytext_ptr = yy_c_buf_p;
X			++yy_c_buf_p;
X
X			switch ( yy_get_next_buffer() )
X				{
X				case EOB_ACT_END_OF_FILE:
X					{
X					if ( yywrap() )
X						{
X						yy_c_buf_p =
X						yytext_ptr + YY_MORE_ADJ;
X						return EOF;
X						}
X
X					YY_NEW_FILE;
X#ifdef __cplusplus
X					return yyinput();
X#else
X					return input();
X#endif
X					}
X
X				case EOB_ACT_CONTINUE_SCAN:
X					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
X					break;
X
X				case EOB_ACT_LAST_MATCH:
X#ifdef __cplusplus
X					YY_FATAL_ERROR(
X					"unexpected last match in yyinput()" );
X#else
X					YY_FATAL_ERROR(
X					"unexpected last match in input()" );
X#endif
X				}
X			}
X		}
X
X	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
X	*yy_c_buf_p = '\0';	/* preserve yytext */
X	yy_hold_char = *++yy_c_buf_p;
X
X	return c;
X	}
X
X
X#ifdef YY_USE_PROTOS
Xvoid yyrestart( FILE *input_file )
X#else
Xvoid yyrestart( input_file )
XFILE *input_file;
X#endif
X	{
X	if ( ! yy_current_buffer )
X		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
X
X	yy_init_buffer( yy_current_buffer, input_file );
X	yy_load_buffer_state();
X	}
X
X
X#ifdef YY_USE_PROTOS
Xvoid yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
X#else
Xvoid yy_switch_to_buffer( new_buffer )
XYY_BUFFER_STATE new_buffer;
X#endif
X	{
X	if ( yy_current_buffer == new_buffer )
X		return;
X
X	if ( yy_current_buffer )
X		{
X		/* Flush out information for old buffer. */
X		*yy_c_buf_p = yy_hold_char;
X		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
X		yy_current_buffer->yy_n_chars = yy_n_chars;
X		}
X
X	yy_current_buffer = new_buffer;
X	yy_load_buffer_state();
X
X	/* We don't actually know whether we did this switch during
X	 * EOF (yywrap()) processing, but the only time this flag
X	 * is looked at is after yywrap() is called, so it's safe
X	 * to go ahead and always set it.
X	 */
X	yy_did_buffer_switch_on_eof = 1;
X	}
X
X
X#ifdef YY_USE_PROTOS
Xvoid yy_load_buffer_state( void )
X#else
Xvoid yy_load_buffer_state()
X#endif
X	{
X	yy_n_chars = yy_current_buffer->yy_n_chars;
X	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
X	yyin = yy_current_buffer->yy_input_file;
X	yy_hold_char = *yy_c_buf_p;
X	}
X
X
X#ifdef YY_USE_PROTOS
XYY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
X#else
XYY_BUFFER_STATE yy_create_buffer( file, size )
XFILE *file;
Xint size;
X#endif
X	{
X	YY_BUFFER_STATE b;
X
X	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
X
X	if ( ! b )
X		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
X
X	b->yy_buf_size = size;
X
X	/* yy_ch_buf has to be 2 characters longer than the size given because
X	 * we need to put in 2 end-of-buffer characters.
X	 */
X	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
X
X	if ( ! b->yy_ch_buf )
X		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
X
X	yy_init_buffer( b, file );
X
X	return b;
X	}
X
X
X#ifdef YY_USE_PROTOS
Xvoid yy_delete_buffer( YY_BUFFER_STATE b )
X#else
Xvoid yy_delete_buffer( b )
XYY_BUFFER_STATE b;
X#endif
X	{
X	if ( b == yy_current_buffer )
X		yy_current_buffer = (YY_BUFFER_STATE) 0;
X
X	yy_flex_free( (void *) b->yy_ch_buf );
X	yy_flex_free( (void *) b );
X	}
X
X
X#ifdef YY_USE_PROTOS
Xvoid yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
X#else
Xvoid yy_init_buffer( b, file )
XYY_BUFFER_STATE b;
XFILE *file;
X#endif
X	{
X	b->yy_input_file = file;
X
X	/* We put in the '\n' and start reading from [1] so that an
X	 * initial match-at-newline will be true.
X	 */
X
X	b->yy_ch_buf[0] = '\n';
X	b->yy_n_chars = 1;
X
X	/* We always need two end-of-buffer characters.  The first causes
X	 * a transition to the end-of-buffer state.  The second causes
X	 * a jam in that state.
X	 */
X	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
X	b->yy_ch_buf[2] = YY_END_OF_BUFFER_CHAR;
X
X	b->yy_buf_pos = &b->yy_ch_buf[1];
X
X	b->yy_is_interactive = file ? isatty( fileno(file) ) : 0;
X
X	b->yy_fill_buffer = 1;
X
X	b->yy_buffer_status = YY_BUFFER_NEW;
X	}
X
X
X#ifdef YY_USE_PROTOS
Xstatic void yy_push_state( int new_state )
X#else
Xstatic void yy_push_state( new_state )
Xint new_state;
X#endif
X	{
X	if ( yy_start_stack_ptr >= yy_start_stack_depth )
X		{
X		int new_size;
X
X		yy_start_stack_depth += YY_START_STACK_INCR;
X		new_size = yy_start_stack_depth * sizeof( int );
X
X		if ( ! yy_start_stack )
X			yy_start_stack = (int *) yy_flex_alloc( new_size );
X
X		else
X			yy_start_stack = (int *) yy_flex_realloc(
X					(void *) yy_start_stack, new_size );
X
X		if ( ! yy_start_stack )
X			YY_FATAL_ERROR(
X			"out of memory expanding start-condition stack" );
X		}
X
X	yy_start_stack[yy_start_stack_ptr++] = YY_START;
X
X	BEGIN(new_state);
X	}
X
X
Xstatic void yy_pop_state()
X	{
X	if ( --yy_start_stack_ptr < 0 )
X		YY_FATAL_ERROR( "start-condition stack underflow" );
X
X	BEGIN(yy_start_stack[yy_start_stack_ptr]);
X	}
X
X
Xstatic int yy_top_state()
X	{
X	return yy_start_stack[yy_start_stack_ptr - 1];
X	}
X
X
X#ifdef YY_USE_PROTOS
Xstatic void yy_fatal_error( const char msg[] )
X#else
Xstatic void yy_fatal_error( msg )
Xchar msg[];
X#endif
X	{
X	(void) fprintf( stderr, "%s\n", msg );
X	exit( 1 );
X	}
X
X
X
X/* Redefine yyless() so it works in section 3 code. */
X
X#undef yyless
X#define yyless(n) \
X	do \
X		{ \
X		/* Undo effects of setting up yytext. */ \
X		yytext[yyleng] = yy_hold_char; \
X		yy_c_buf_p = yytext + n - YY_MORE_ADJ; \
X		yy_hold_char = *yy_c_buf_p; \
X		*yy_c_buf_p = '\0'; \
X		yyleng = n; \
X		} \
X	while ( 0 )
X
X
X/* Internal utility routines. */
X
X#ifndef yytext_ptr
X#ifdef YY_USE_PROTOS
Xstatic void yy_flex_strncpy( char *s1, const char *s2, int n )
X#else
Xstatic void yy_flex_strncpy( s1, s2, n )
Xchar *s1;
Xconst char *s2;
Xint n;
X#endif
X	{
X	register int i;
X	for ( i = 0; i < n; ++i )
X		s1[i] = s2[i];
X	}
X#endif
X
X
X#ifdef YY_USE_PROTOS
Xstatic void *yy_flex_alloc( unsigned int size )
X#else
Xstatic void *yy_flex_alloc( size )
Xunsigned int size;
X#endif
X	{
X	return (void *) malloc( size );
X	}
X
X#ifdef YY_USE_PROTOS
Xstatic void *yy_flex_realloc( void *ptr, unsigned int size )
X#else
Xstatic void *yy_flex_realloc( ptr, size )
Xvoid *ptr;
Xunsigned int size;
X#endif
X	{
X	return (void *) realloc( ptr, size );
X	}
X
X#ifdef YY_USE_PROTOS
Xstatic void yy_flex_free( void *ptr )
X#else
Xstatic void yy_flex_free( ptr )
Xvoid *ptr;
X#endif
X	{
X	free( ptr );
X	}
X# line 216 "scan.l"
X
X
X
X/* init_scanner
X * initialize necessary variables and set up the input file pointer
X * before processing a file.
X *
X * Called from csize.c
X *
X */
X
Xvoid
Xinit_scanner(FILE *fp, char *filename) 
X{
X  C_newlines    = 0;
X  C_blank_lines = 0;
X  C_lines_w_comments = 0;
X  C_nb_nc_lines = 0;
X  C_semicolons = 0;
X  C_pp_directives = 0;
X
X  Lex_errors = 0;
X  prev_line_with_comment = -1;
X  prev_line_with_text    = -1;
X
X  Filename = filename;
X
X  /* although the flex documentation states that assigning
X   * to yyin like this:
X   *         yyin = fp;
X   * should be equivalent to 
X   *         yyrestart(fp);
X   * the run-time behavior of scanners generated with flex 2.4.6
X   * is different; with only the assignment, the scanner complains
X   * of an illegal characater at line 1, character 1 of subsequent
X   * files.  So this is a workaround.
X   */
X  yyrestart(fp); 
X}
X
X
X/* count_nb_nc_lines
X * count nonblank noncomment lines in the input, but
X * ensure that we don't count the same line twice by
X * checking and/or updating the appropriate variable
X *
X * called by functions; no dependence on yytext
X *
X */
X
Xstatic void
Xcount_nb_nc_lines(void)
X{
X  if (C_newlines != prev_line_with_text) {
X    ++C_nb_nc_lines;
X    prev_line_with_text = C_newlines;
X  }
X}
X
X
X/* count
X * count columns for lines with *nonblank noncomment* text.
X * Optionally echo the buffer yytext, and call count_nb_nc_lines  
X * to count the line.
X *
X * called by lexer with the *nonblank noncomment* token in yytext
X *
X */
X
Xstatic void
Xcount(void)
X{
X  Column += yyleng;
X  if (Echo) 
X    ECHO;
X  count_nb_nc_lines();
X}
X
X
X/* semicolon
X * saw a semicolon in the input, just bump the appropriate counter
X * 
X * count() is called before this function
X *
X * called by lexer but has no dependence on yytext
X *
X */
X
Xstatic void
Xsemicolon(void)
X{
X  ++C_semicolons;
X}
X
X
X/* pp_dir
X * Read characters until the terminating newline ('\n') is found.  Count the
X * number of directives.  Even though no text may appear after a directive 
X * on a line, count columns so that the function newline() can be used.
X *
X * Complications:
X *     Escaped backslash characters ('\\').  These do nothing.
X *     Escaped newline characters (continuation lines).  These force the
X *         function to update newline and nonblank noncomment line counts.  
X *         Note that a continuation line can consist of a single newline,
X *         or only whitespace and a newline; in both cases the continuation
X *         line terminates the preprocessor directive.  The algorithm makes 
X *         provisions to treat both cases identically.  Those blank-ish 
X *         continuation lines, although they look blank, are counted as 
X *         nonblank noncomment lines.
X *     Comments that begin on the pp_dir's line.  These must be processed
X *         until the closing * and / is found, after which processing of 
X *         the pp resumes.  See the part in K&Rrev2, p. 229, about 
X *         logically successive preprocessor phases.
X *     The terminating newline must be given back via unput so that
X *         the lexer can correctly identify the beginning of lines
X *         for rules that use the caret ('^')
X *
X * Input errors:
X *     EOF condition before the terminating newline
X * 
X * count() is called before this function, which marks the first line of
X *     the preprocessor directive as having nonblank noncomment text.  
X *
X * Called by the lexer, but no dependence on yytext
X *
X */
X
Xstatic void
Xpp_dir(void)
X{
X  char c;
X  int in_pp_dir = 1;
X  int saw_forwslash = 0;
X  int apply_backslash = 0;
X  
X  ++C_pp_directives;
X
X  while (in_pp_dir && (c = input()) != EOF) {
X
X    if (c == '\n') {             /* first take care of newline chars */
X      if (apply_backslash) {
X	apply_backslash = 0;
X	newline();               /* register the newline globally */
X	count_nb_nc_lines();     /* count the new nb nc line */
X      }
X      else {
X	if (Column == 0)         /* if Column has value 0, newline() will */
X	  ++Column;              /* count the line as blank; don't let it */
X	unput(c);                /* give back the nl */
X	in_pp_dir = 0;           /* done with this pp dir */
X      }
X    }
X    else {
X
X      if (Echo)                  /* only do echo processing for non-newlines */
X	putchar(c);
X      ++Column;
X
X      switch (c) {
X      case '\\':
X	if (apply_backslash) {
X	  apply_backslash = 0;
X	}
X	else {
X	  apply_backslash = 1;
X	}
X	saw_forwslash = 0;
X	break;
X      case '/':
X	saw_forwslash = 1;
X	apply_backslash = 0;
X	break;
X      case '*':
X	if (saw_forwslash) {
X	  comment(0);             /* 0 means don't echo the start token again */
X	}
X	saw_forwslash = 0;
X	apply_backslash = 0;
X	break;
X      default:   
X	apply_backslash = 0;      /* any char after f/b-slash turns off the flags */
X	saw_forwslash = 0;
X	break;
X      }
X    }
X
X  } /* while */
X
X  if (c == EOF)
X    scan_error("EOF in preprocessor directive");
X}
X
X
X/* string_lit
X * Read characters until the closing quote ('"') is found.  Do not count
X * string literals. Count columns because a string literal may be followed 
X * by other text on a line. 
X *
X * Complications:
X *     Escaped backslash characters ('\\').  These do nothing.
X *     Escaped quote characters ('\"').  These do not terminate
X *         the string literal.
X *     Escaped newline characters (continuation lines).  These force the
X *         function to update newline and nonblank noncomment line counts.  
X *         Note that a continuation line can never be entirely blank - 
X *         either it has another escaped newline, or it has the terminating 
X *         quote.  This prevents the anomaly of counting a blank line as
X *         something else, as is the case for preprocessor directives.
X *
X * Input errors:
X *     unescaped newline before the terminating quote
X *     EOF condition     before the terminating quote
X * 
X * count() is called before this function, which marks the first line of
X *     the string literal line as having nonblank noncomment text.  
X *
X * Called by the lexer, but no dependence on yytext
X *
X */
X
Xstatic void
Xstring_lit(void)
X{
X  char c;
X  int in_string_lit = 1;
X  int apply_backslash = 0;       /* apply backslash to the next char seen */
X
X  while (in_string_lit && (c = input()) != EOF) {
X
X    if (c == '\n') {             /* first take care of newline chars */
X      if (apply_backslash) {
X	apply_backslash = 0;
X	newline();               /* register the newline globally */
X	count_nb_nc_lines();     /* count the new nb nc line */
X      }
X      else {
X	scan_error("newline in string literal");
X	unput(c);                /* give back the newline */
X	in_string_lit = 0;       /* give up on this string literal */
X      }
X    }
X    else {                       /* prev char was not a newline */
X      switch (c) {
X      case '\\':
X	if (apply_backslash) 
X	  apply_backslash = 0;
X	else
X	  apply_backslash = 1;
X	break;
X      case '"':
X	if (apply_backslash) 
X	  apply_backslash = 0;
X	else
X	  in_string_lit = 0;     /* finished with this string literal */
X	break;
X      default:   
X	if (apply_backslash)     /* any char after bslash turns off the flag */
X	  apply_backslash = 0;
X	break;
X      }
X
X      if (Echo)                  /* only do echo processing for non-newlines */
X	putchar(c);
X      ++Column;
X    }
X
X  } /* while */
X
X  if (c == EOF)
X    scan_error("EOF in string literal");
X}
X
X
X/* count_ws
X * count the columns in the buffer yytext (only white space, never nl)
X * adjusting for tabs 
X *
X * called by the lexer with the whitespace in yytext
X *
X */
X
Xstatic void
Xcount_ws(void)
X{
X  int i;
X  
X  if (Echo) 
X    ECHO;
X
X  for (i = 0; yytext[i] != '\0'; i++)
X    if (yytext[i] == '\t')
X      Column += 8 - (Column % 8);
X    else
X      Column++;
X}  
X
X
X/* whitespace_line
X * Process a line that is not empty but only has whitespace.
X * The newline is *not* part of yytext at this point.
X * Do not do *anything* except echo the line, if desired.
X * Because the Column variable is not changed, it will be
X * 0 when newline is called, which will count the blank line.
X *
X * called by the lexer with the whitespace in yytext
X *
X */
X
Xstatic void
Xwhitespace_line(void)
X{
X  if (Echo) 
X    ECHO;
X}
X
X
X/* newline
X * Count all newline characters.  Also check the value of the Column 
X * variable to catch lines with nothing but whitespace (blank lines).
X * 
X * Note that blank lines are somewhat difficult to catch with a lex 
X * pattern, because the pattern ``^"\n"'', meaning match a newline that 
X * occurs first on a line, doesn't seem to work.
X *
X * Note also that if the lex pattern to match a line with only whitespace
X * fires, then the Column variable will not be incremented, and this 
X * function will be called with Column = 0.  I call this a virtual 
X * column 0, because newline really didn't occur as the first character
X * on the line, we just pretend that it did.
X *
X * Called by the lexer *and* other functions; no dependence on yytext
X *
X */
X
Xstatic void
Xnewline(void)
X{
X  if (Echo) 
X    putchar('\n');
X  ++C_newlines;
X  if (Column == 0) {
X    ++C_blank_lines;
X  }
X  Column = 0;
X}
X
X
X/* count_line_w_comment
X * Cuarantee that we don't count a line as having a comment twice
X *
X * Called by functions; no dependence on yytext
X *
X */
X
Xstatic void
Xcount_line_w_comment(void)
X{
X  if (C_newlines != prev_line_with_comment) {
X    ++C_lines_w_comments;
X    prev_line_with_comment = C_newlines;
X  }
X}
X
X
X/* comment
X * Read characters until the closing two-character sequence '*' and '/'
X * is found.  Count the lines with comments.  Count columns because a 
X * comment may be followed by other text on a line.
X *
X * Complications:
X *     Newline characters.  These force the function to update the counts
X *         of newlines and the number of lines with comments.  A line
X *         within a comment that has zero or more whitespace characters 
X *         and a newline, although blank, will be counted as a comment line.
X * Input errors:
X *     EOF condition before the terminating token
X * 
X * This fn implements a simple FSA to recognize the end of a comment.
X * The original code was reused from Jeff Lee's distribution and
X * amended to count lines.  While I don't much like gotos, his 
X * implementation is highly concise and keeps code redundancy to a 
X * minimum.  This code is far more concise than, for example, the 
X * code from the flexdoc(1) man page, when you consider all the
X * intermediate cases in which characters must be counted.
X *
X * Called by the lexer with the comment start token in yytext,
X * and also called by pp_dir with garbage in yytext, so don't
X * depend on yytext (and don't use ECHO).  Argument tells whether
X * it should echo the comment start token.
X *
X */
X
Xstatic void
Xcomment(int echo_start)
X{
X  register int c, lookahead;
X
X  if (Echo && echo_start) { 
X    putchar('/');
X    putchar('*');
X  }
X  Column += yyleng;
X
X  /* starting a comment, count the line if necessary */
X  count_line_w_comment();
X  
X  /* deal with all characters in this while loop */
X loop:
X  while ((c = input()) != EOF) {    /* find a star */
X
X    if (c == '\n') {
X      if (Column == 0)      /* if Column has value 0, newline() will count */
X	++Column;           /* the line as blank, which we don't want */
X      newline();
X      count_line_w_comment();
X    }
X    else {
X      if (Echo) 
X	putchar(c);
X      ++Column;
X    }
X
X    if (c == '*')                   /* found one, leave the while loop */
X      break;
X  }
X
X  if (c != EOF && (lookahead = input()) != '/') {    /* check for a slash */
X    unput(lookahead);
X    goto loop;
X  }
X
X  if (c == EOF) {
X    scan_error("EOF in comment");
X  }
X  else {
X    if (Echo) 
X      putchar('/');
X  }
X}
X
X
X/* check_type
X * pseudo code --- this is what it should check
X *
X *	if (yytext == type_name)
X *		return(TYPE_NAME);
X *	else
X *		return(IDENTIFIER);
X *
X * If it did, it would be easy to build a C language
X * recognizer, and then trivial to count declarations
X * and executable statements.
X *
X * However, the function only returns IDENTIFIER
X *
X */
X
Xstatic int
Xcheck_type(void)
X{
X  return(IDENTIFIER);
X}
X
X
X/* scan_error
X * print an informative error message with file, line info.
X * if echoing is on, indicate the column where the error
X * was found by using the Column variable
X *
X */
X
Xstatic void
Xscan_error(char *s)
X{
X  fflush(stdout);
X  ++Lex_errors;
X  if (Echo)
X    printf("\n%*s\n%*s\n", Column, "^", Column, s);
X  else
X    printf("\"%s\", line %d: %s\n", Filename, C_newlines + 1, s);
X}
X
X
X/* bad_char
X * bump up the column count and call the error function
X *
X * Called by the lexer with the unrecognized character in yytext
X *
X */
X
Xstatic void
Xbad_char(void)
X{
X  int i;
X
X  if (Echo)
X    ECHO;
X  ++Column;
X  scan_error("bad character");
X  if (Echo) /* restore output to column where we left off */
X    for (i = 0; i < Column; ++i)
X      putchar(' ');
X}
X
X
X/* yywrap
X * supply a trivial version of yywrap
X * to eliminate the need to link against libfl
X * the value 1 means stop at the end of the file
X * (the file pointer has not been aimed at a new file)
X *
X * Called by the lexer at the end of the input
X *
X */
X
Xint
Xyywrap(void)
X{
X  return 1;
X}
SHAR_EOF
chmod 0644 scan.c.flex ||
echo 'restore of scan.c.flex failed'
Wc_c="`wc -c < 'scan.c.flex'`"
test 67608 -eq "$Wc_c" ||
	echo 'scan.c.flex: original size 67608, current size' "$Wc_c"
fi
true || echo 'restore of t-dir.tar.Z.uu failed'
echo End of part 3, continue with part 4
exit 0

exit 0 # Just in case...

