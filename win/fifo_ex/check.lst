Abraxas Software (R) CodeCheck Unix version 5.02

Checking extended ANSI C file fifotst.c with rules from ansi.cc, posix.cc:

      1 	#define _POSIX_SOURCE
      2 	
      3 	#include <stdlib.h>
      4 	#include "cchk_missing_stdlib.h"
      5 	#include <stdarg.h>
      6 	#include "cchk_missing_stdarg.h"
      7 	#include <ctype.h>
      8 	#include <string.h>
      9 	#include <stdio.h>
     10 	#include <errno.h> /* perror() */
     11 	#include <unistd.h>
     12 	#include "cchk_missing_unistd.h"
     13 	#include <fcntl.h>	/* O_RDONLY - file open mode needed
     14 				 * by open_parent2child_fifo () --
     15 				 * called in the server (client
     16 				 * calls it via connect_to_parent() */
     17 	#include <sys/wait.h>	/* wait(), waitpid() */
     18 	
     19 	#include "semops.h"	/* To create semaphore for the
     20 				 * child process. */
     21 	#include "some_utils.h"	/* util_abort() and growstr()
     22 				 * utilities. */
     23 	#include "hash.h"	/* Hash table to match process ID
     24 				 * to a FIFO. */
     25 	#include "fifo.h"
     26 	
     27 	void            flprintf (char *printf_fmt_str,...)
     28 	{
     29 	    va_list         arguments;
     30 	
     31 	    va_start (arguments, printf_fmt_str);
     32 	    vfprintf (stdout, printf_fmt_str, arguments);
     33 	    fflush (stderr);
     34 	    va_end (arguments);
     35 	}
     36 	
     37 	/*******************************************************************************
     38 	 * FUNCTION:    SUB_CLIENT
     39 	 *      Another sub-process
     40 	 ******************************************************************************/
     41 	static void     sub_client (shared_fifodata_tt *parent2child, int mutex)
     42 	{
     43 	    char            child_pidstr[INTLEN];
     44 	    char            message[1024];
     45 	    reply_fifodata_tt *child2parent = NULL;
     46 	    const char     *reply_ptr;
     47 	    size_t          reply_len;	/* Length of the parents
     48 					 * reply to your message. */
     49 	    server_command_tt command;
     50 	    int             shared_val;
     51 	
     52 	    sprintf (child_pidstr, "%d", getpid ());
     53 	    flprintf ("Sub-Child created.  PID = %s\n", child_pidstr);
     54 	    connect_to_parent (parent2child, child_pidstr, &child2parent);
     55 	    message[0] = '\0';
     56 	/* Begin critical section. */
     57 	    sem_wait (mutex);
     58 	    send2parent (parent2child, SRV_GET_VAL, message);
     59 	    command = receive_fm_parent (child2parent, &reply_len);
     60 	    reply_ptr = reply_fifo_data (child2parent);
     61 	    shared_val = atoi (reply_ptr);
     62 	    ++shared_val;
     63 	    sprintf (message, "%d", shared_val);
     64 	    send2parent (parent2child, SRV_SET_VAL, message);
     65 	    sem_signal (mutex);
     66 	/* End critical section. */
     67 	
     68 	    flprintf ("shared_val = %d in sub-child %d.\n", shared_val, getpid ());
     69 	    destroy_child2parent (child2parent);
     70 	    free (child2parent);
     71 	    exit (0);
     72 	}
     73 	
     74 	/*******************************************************************************
     75 	 * FUNCTION:    CLIENT
     76 	 ******************************************************************************/
     77 	#define NUM_SUBCHILD	4
     78 	void            client (shared_fifodata_tt *parent2child, int mutex)
     79 	{
     80 	    char            child_pidstr[INTLEN], message[1024];
     81 	    reply_fifodata_tt *child2parent = NULL;
     82 	    const char     *reply_ptr;
     83 	    size_t          reply_len;
     84 	    server_command_tt command;
     85 	    int             subchild_cnt = 0;
     86 	    int             shared_val;
     87 	
     88 	    sprintf (child_pidstr, "%d", getpid ());
     89 	    flprintf ("Child created.  PID = %s\n", child_pidstr);
     90 	    connect_to_parent (parent2child, child_pidstr, &child2parent);
     91 	
     92 	/* Begin critical section. */
     93 	    sem_wait (mutex);
     94 	    send2parent (parent2child, SRV_GET_VAL, message);
     95 	    command = receive_fm_parent (child2parent, &reply_len);
     96 	    reply_ptr = reply_fifo_data (child2parent);
     97 	    shared_val = atoi (reply_ptr);
     98 	    ++shared_val;
     99 	    sprintf (message, "%d", shared_val);
    100 	    send2parent (parent2child, SRV_SET_VAL, message);
    101 	    sem_signal (mutex);
    102 	/* End critical section. */
    103 	
    104 	    while (subchild_cnt < NUM_SUBCHILD) {
    105 		if (fork () == 0)
    106 		    sub_client (parent2child, mutex);
    107 		else
    108 		    subchild_cnt++;
    109 	    }
    110 	/* Wait for sub-processes to finish. */
    111 	    while (subchild_cnt > 0) {
    112 		flprintf ("Sub-client %d completed\n", wait (0));
    113 		--subchild_cnt;
    114 	    }
    115 	    message[0] = '\0';
    116 	    send2parent (parent2child, SRV_SHUTDOWN, message);
    117 	
    118 	    destroy_child2parent (child2parent);
    119 	    free (child2parent);
    120 	    exit (0);
    121 	}
    122 	
    123 	/*******************************************************************************
    124 	 * FUNCTION:    SERVER
    125 	 ******************************************************************************/
    126 	void            server (shared_fifodata_tt *parent2child, int shared_val)
    127 	{
    128 	    char            child_pidstr[INTLEN];
    129 	    server_command_tt command;
    130 	    const char     *dataptr;
    131 	    char           *buf;
    132 	    size_t          datalen;
    133 	    int             old_val;
    134 	
    135 	    flprintf ("Executing parent code.\n");
    136 	
    137 	/* All children write to the parent2child FIFO. */
    138 	    open_parent2child_fifo (parent2child, O_RDONLY);
    139 	    if ((buf = malloc (shared_fifo_bufsiz (parent2child))) == NULL)
    140 		util_abort (__LINE__, __FILE__, "malloc() failed.\n");
    141 	
    142 	    do {
    143 		command = receive_fm_child (parent2child, child_pidstr, &datalen);
    144 		dataptr = shared_fifo_data (parent2child);
    145 	
    146 		switch (command) {
    147 		    case SRV_CONNECT:
    148 			flprintf ("SRV_CONNECT: Parent received a connect message "
    149 			"from %s.\n\tParent will open the child\'s"
    150 			  "reply FIFO.\n", child_pidstr, command);
    151 			parent_open_reply_fifo (parent2child, child_pidstr);
    152 			break;
    153 	
    154 		    case SRV_GET_VAL:
    155 			sprintf (buf, "%d", shared_val);
    156 			send2child (parent2child, child_pidstr, command, buf);
    157 			break;
    158 	
    159 		    case SRV_SET_VAL:
    160 			old_val = shared_val;
    161 			shared_val = atoi (dataptr);
    162 			flprintf ("Process %s changed shared_val from %d to %d.\n",
    163 			       child_pidstr, old_val, shared_val);
    164 			break;
    165 	
    166 		    case SRV_SHUTDOWN:
    167 			flprintf ("SRV_SHUTDOWN: Parent received from %s.\n",
    168 				  child_pidstr);
    169 			break;
    170 		}
    171 	    } while (command != SRV_SHUTDOWN);
    172 	    destroy_fifos (parent2child);
    173 	    sleep (1);
    174 	}
    175 	
    176 	/*******************************************************************************
    177 	 * FUNCTION:    MAIN
    178 	 ******************************************************************************/
    179 	shared_fifodata_tt *parent2child;
    180 	int             main (void)
    181 	{
    182 	    char            parent_pidstr[INTLEN];	/* String representation
    183 							 * of the parent process
    184 							 * ID. */
    185 	    pid_t           pid;	/* Process ID returned from
    186 					 * fork() */
    187 	    int             shared_val = 0;	/* A value to be shared
    188 						 * by all sub-processes. */
    189 	    int             mutex = sem_create ();	/* Semaphore protecting
    190 							 * shared_val. */
    191 	
    192 	    sprintf (parent_pidstr, "%d", (int) getpid ());
    193 	    parent2child = init_parent2child_fifo (parent_pidstr);
    194 	
    195 	    if ((pid = fork ()) == -1) {
    196 		perror ("Erron in fork()");
    197 		exit (-1);
    198 	    }
    199 	    else if (pid == 0)
    200 		client (parent2child, mutex);	/* Child */
    201 	    else
    202 		server (parent2child, shared_val);	/* Parent */
    203 	
    204 	    return (0);
    205 	}



Checking extended ANSI C file fifo.c with rules from ansi.cc, posix.cc:

      1 	/*******************************************************************************
      2 	 * MODULE:	FIFO.C
      3 	 *
      4 	 * PURPOSE:	Utilities to use POSIX.1 FIFOs to provide bidirectional
      5 	 *		communication between a server process and its fork()ed child
      6 	 *		processes
      7 	 *
      8 	 * FUNCTIONS DECLARED
      9 	 *	EXTERNAL:	<required>
     10 	 *	LOCAL:		<optional>
     11 	 *
     12 	 * USE:
     13 	 *
     14 	 *	The data passed between processes is in the following format when
     15 	 *	it is written to/read from any of the FIFOs:
     16 	 *	<sender process ID string><blank><command num string><blank><data len>
     17 	 *		<blank><data>
     18 	 *
     19 	 * PROTOCOL:
     20 	 *
     21 	 *	IN SERVER PROCESS, BEFORE CALLING fork():
     22 	 *
     23 	 *	shared_fifodata_tt *parent2child;
     24 	 *	char            parent_pidstr[INTLEN]; --String representation of the
     25 	 *					parent (server) process ID.
     26 	 *	pid_t           pid; --Process ID returned from fork()
     27 	 *
     28 	 *	sprintf (parent_pidstr, "%d", (int) getpid ());
     29 	 *	parent2child = init_parent2child_fifo (parent_pidstr);
     30 	 *	if ((pid = fork ()) == -1)
     31 	 *	{
     32 	 *		perror ("Erron in fork()");
     33 	 *		exit (-1);
     34 	 *	}
     35 	 *	else if (pid == 0)
     36 	 *		client (parent2child); --Execute client (child) code.
     37 	 *	else
     38 	 *		server (parent2child); --Execute server (parent) code.
     39 	 *
     40 	 *
     41 	 *	IN THE CLIENT CODE:
     42 	 *	void            client (shared_fifodata_tt * parent2child)
     43 	 *	{
     44 	 *		char            child_pidstr[INTLEN];
     45 	 *		char	       *message;
     46 	 *		reply_fifodata_tt *child2parent = NULL;
     47 	 *		const char     *reply_ptr;
     48 	 *		size_t          reply_len;
     49 	 *		server_command_tt command; -- Vaule from an enumerated type.
     50 	 *
     51 	 *		sprintf (child_pidstr, "%d", getpid ());
     52 	 *		connect_to_parent (parent2child, child_pidstr, &child2parent);
     53 	 *
     54 	 *		message = malloc (shared_fifo_bufsiz(parent2child));
     55 	 *		sprintf (message, "sub_client's message.");
     56 	 *		send2parent (parent2child, SRV_ECHO, message);
     57 	 *		receive_fm_parent (child2parent, &reply_len);
     58 	 *		reply_ptr = reply_fifo_data (child2parent);
     59 	 *
     60 	 *		... continue sending messages and getting replies ...
     61 	 *		--CRITICAL only let ONE client send the shutdown message to
     62 	 *		--the server; call wait() once for each spawned subchild.
     63 	 *		sprintf (message, "");
     64 	 *		send2parent (parent2child, SRV_SHUTDOWN, message);
     65 	 *		destroy_child2parent (child2parent);
     66 	 *		free (child2parent);
     67 	 *		free (message);
     68 	 *		exit (0);
     69 	 *	}
     70 	 *
     71 	 *
     72 	 *	IN THE SERVER CODE
     73 	 *	void            server (shared_fifodata_tt * parent2child)
     74 	 *	char            child_pidstr[INTLEN];
     75 	 *	server_command_tt command;
     76 	 *	const char     *dataptr; -- Points at data in the parent2child
     77 	 *				 -- internal structures; therefore const.
     78 	 *	char           *echobuf; -- Make a local copy of the data before
     79 	 *			         -- echoing it back to client, during the
     80 	 *				 -- SRV_ECHO command  (Dont pass a ptr into
     81 	 *				 -- the parent2child internal structures).
     82 	 *	size_t          datalen;
     83 	 *
     84 	 *	open_parent2child_fifo (parent2child, O_RDONLY);
     85 	 *	echobuf = malloc (shared_fifo_bufsiz (parent2child));
     86 	 *
     87 	 *	do
     88 	 *	{ -- Process commands until you get an SRV_SHUTDOWN command.
     89 	 *		command = receive_fm_child (parent2child, child_pidstr,
     90 	 *						&datalen);
     91 	 *		dataptr = shared_fifo_data (parent2child);
     92 	 *		switch (command)
     93 	 *		{
     94 	 *			-- The SRV_CONNECT message is automatically sent by the
     95 	 *			-- client process when it calls connect_to_parent()
     96 	 *			case SRV_CONNECT:
     97 	 *				parent_open_reply_fifo (parent2child,
     98 	 *								child_pidstr);
     99 	 *				break;
    100 	 *
    101 	 *			-- SRV_ECHO is a test message you can send.  You should
    102 	 *			-- get your message echoed right back to you.
    103 	 *			case SRV_ECHO:
    104 	 *				strcpy (echobuf, dataptr);
    105 	 *				send2child (parent2child, child_pidstr,
    106 	 *							command, echobuf);
    107 	 *				break;
    108 	 *
    109 	 *			... any other commands you add here are handled here ...
    110 	 *
    111 	 *			default:
    112 	 *				printf ("Parent received %d byte message from "
    113 	 *					"%s.  Command %d, message:\n\t\"%s\"\n",
    114 	 *					 datalen, child_pidstr, command,
    115 	 *					 dataptr);
    116 	 *		} -- end switch
    117 	 *	} while (command != SRV_SHUTDOWN);
    118 	 *	destroy_fifos (parent2child);
    119 	 *	free (echobuf);
    120 	 *
    121 	 *
    122 	 *
    123 	 * AUTHOR:	Malcolm L. Franklin, Arizona State University
    124 	 * $Author: franklin $
    125 	 *******************************************************************************
    126 	 * $Date: 1994/10/01 19:38:29 $
    127 	 * $State: Exp $
    128 	 * $Locker:  $
    129 	 * $Source: /all/franklin/thesis/descartes/win/fifo_ex/RCS/fifo.c,v $
    130 	 *
    131 	 ******************************************************************************/
    132 	
    133 	#if 0
      - 	/******************************************************************************
      - 	 *
      - 	$Log: fifo.c,v $
      - 	 * Revision 1.1  1994/10/01  19:38:29  franklin
      - 	 * Initial revision
      - 	 *
      - 	 * Revision 1.37  1994/08/22  00:22:28  franklin
      - 	 * Add the server processes PID to the name of the FIFO file.
      - 	 * Indent.
      - 	 *
      - 	 * Revision 1.36  1994/08/12  15:56:28  franklin
      - 	 * Try to recover from read() fetching a NULL character
      - 	 * from a FIFO, even though nobody should have put it in
      - 	 * the stream.
      - 	 *
      - 	 * Revision 1.35  1994/08/12  05:01:54  franklin
      - 	 * On the HP, read() will claim to have read a full message
      - 	 * header, even though buf[] contains no new data!  Try to
      - 	 * recover when this happens.
      - 	 *
      - 	 * Revision 1.34  1994/08/12  04:31:23  franklin
      - 	 * WARNING:
      - 	 * Version 1.33 of fifo.c IS ACTUALLY A COPY OF A PREVIOUS
      - 	 * VERSION!  This is the correct file.  Here are the changes:
      - 	 * read() and write() operations can fail when the timeout() SIGALRM
      - 	 * message is received.  Made read/write operations tolerant of this (they
      - 	 * can abort with errno == EINTR.
      - 	 *
      - 	 * Revision 1.32  1994/08/10  19:08:38  franklin
      - 	 * 1. Abort if sscanf() fails to translate a FIFO message header.
      - 	 * 2. Move the SIGPIPE handler to safe.c, and make it reentrant.
      - 	 * 3. Move the #definition of MSG_HEADER_SIZ to fifo.h, so that safe.c can
      - 	 *    see it.  The timeout() signal handler has to build a message header
      - 	 *    manually, because send2parent() and functions that it calls, are not
      - 	 *    reentrant.
      - 	 * 4. Make multiple attempts to read a message header.
      - 	 *
      - 	 * Revision 1.31  1994/08/09  01:08:16  franklin
      - 	 * Added utility function commandval2string()
      - 	 *
      - 	 * Revision 1.30  1994/08/06  22:34:35  franklin
      - 	 * Remove several printf()s that were really slowing down performance.
      - 	 *
      - 	 * Revision 1.29  1994/08/06  18:48:00  franklin
      - 	 * Add "const" qualifier to parameters that are not modified by
      - 	 * the FIFO utilities
      - 	 *
      - 	 * Revision 1.28  1994/08/05  18:47:57  franklin
      - 	 * Dont quit just because you called mkfifo() for a FIFO file
      - 	 * that already existed.
      - 	 *
      - 	 * Revision 1.27  1994/08/05  17:06:04  franklin
      - 	 * Remove "static" keyword from functions parent_open_reply_fifo()
      - 	 * and connect_to_parent.
      - 	 * Remove dataptr parameter from receive_fm_child()
      - 	 * and receive_fm_parent().
      - 	 * Make corrections to PROTOCOL comments.
      - 	 *
      - 	 * Revision 1.26  1994/08/05  02:33:56  franklin
      - 	 * closing parend.
      - 	 *
      - 	 * Revision 1.25  1994/08/05  02:32:45  franklin
      - 	 * and semicolon.
      - 	 *
      - 	 * Revision 1.24  1994/08/05  02:31:43  franklin
      - 	 * Add missing closing brace.
      - 	 *
      - 	 * Revision 1.23  1994/08/05  02:27:32  franklin
      - 	 * 1. Identify static and non-static functions.
      - 	 * 2. Fix error in the "PROTOCOL" comments.
      - 	 * 3. Add utilities for fetching data from a FIFO struct pointer:
      - 	 *    reply_fifo_bufsiz(), reply_fifo_data(),
      - 	 *    shared_fifo_bufsiz(), shared_fifo_data()
      - 	 *
      - 	 * Revision 1.22  1994/08/05  00:14:53  franklin
      - 	 * Move typedefs, #defines, and prototypes required to use this module,
      - 	 * in to fifo.h.
      - 	 *
      - 	 * Revision 1.21  1994/08/04  17:58:17  franklin
      - 	 * Add #includes for cchk_missing_<standard include>.h in order
      - 	 * to get prototypes that CodeCheck doesnt think are there.
      - 	 *
      - 	 * Revision 1.20  1994/08/04  16:44:33  franklin
      - 	 * Moved #include ctype.h before string.h and stdio.h to shut up CodeCheck
      - 	 * message: Prefix "to" was used 1 times before this #include.
      - 	 *
      - 	 * Revision 1.19  1994/08/01  23:38:30  franklin
      - 	 * The suffix "_t" is reserved by POSIX.1
      - 	 *
      - 	 * Revision 1.18  1994/08/01  18:52:19  franklin
      - 	 * This version successfully coordinates server shutdown with the child
      - 	 * and several subchild processes.
      - 	 *
      - 	 * Revision 1.17  1994/08/01  18:08:42  franklin
      - 	 * 1.  I tried to get fancy with the hashing algorithm, and all
      - 	 *    I ended up doing is breaking how the hastable functions
      - 	 *    handled collisions.  Use the integer version of the PID as
      - 	 *    the key field, and let the hash functions do the rest.
      - 	 * 2. Deleted a semicolon after while statement, which resulted in
      - 	 *    an infinite loop ==> "while (subchild_cnt > 0);"
      - 	 *
      - 	 * Revision 1.16  1994/07/31  23:51:35  franklin
      - 	 * Try waiting (wait(0)) for each sub-subprocess to die before sending
      - 	 * the shutdown message to the server.  I do not know if this works or
      - 	 * not, because I goobered up how the hash table handles collisions.
      - 	 *
      - 	 * Revision 1.15  1994/07/31  23:17:23  franklin
      - 	 * First attempt to syncronize server shutdown with multiple child
      - 	 * processes.  The server dies too soon.
      - 	 *
      - 	 * Revision 1.14  1994/07/31  22:00:57  franklin
      - 	 * Free of Purify(tm) errors.
      - 	 *
      - 	 * Revision 1.13  1994/07/30  19:02:37  franklin
      - 	 * Let receive_fm_child() share read_header() and read_msgtext() with
      - 	 * receive_rm_parent.
      - 	 *
      - 	 * Revision 1.12  1994/07/30  17:36:23  franklin
      - 	 * indent
      - 	 *
      - 	 * Revision 1.11  1994/07/30  17:29:57  franklin
      - 	 * The server DOES send replies back to the child that requested the reply.
      - 	 *
      - 	 * Revision 1.8  1994/07/28  04:49:10  franklin
      - 	 * Fixed two BIG problems
      - 	 * 1. I was setting the wrong bits in the call to open().  DONT set the same
      - 	 *    flags you used when you called mkfifo().  mkfifo() creates an object
      - 	 *    in the file sytem.  mkfifo() expects read/write permission bit settings
      - 	 *    a la chmod(1)(2).
      - 	 * 2. Allocate enough room in header_string[] for 3 integers and their delimite
      - 	 *    not just 1 integer.
      - 	 *
      - 	 * Revision 1.7  1994/07/27  20:39:30  franklin
      - 	 * Version ftpd to ASU to try on Solaris 2.3.  BAD NEWS: The fifo works FINE
      - 	 * on HP-UX 9, seems to work OK on Solaris 2.3, but HANGS DEAD on SunOS 4.1.3.
      - 	 * Even worse, it HANGS OBJECTCENTER when I try to debug it!
      - 	 *
      - 	 * Revision 1.6  1994/07/25  21:36:02  franklin
      - 	 * I tried to use variable message header lengths.  It did not work.
      - 	 *
      - 	 * Revision 1.5  1994/07/25  00:11:00  franklin
      - 	 * Integrage hash table functions.
      - 	 *
      - 	 * Revision 1.4  1994/07/23  22:32:51  franklin
      - 	 * indent
      - 	 *
      - 	 * Revision 1.3  1994/07/23  21:47:42  franklin
      - 	 * First version that will pass data from the child to the parent.
      - 	 *
      - 	 * Revision 1.1  1994/07/23  04:24:59  franklin
      - 	 * Initial revision
      - 	 *
      - 	 ******************************************************************************/
    287 	#endif
    288 	
    289 	static char    *rcsid = "$Id: fifo.c,v 1.1 1994/10/01 19:38:29 franklin Exp $";
    290 	
    291 	
    292 	#include <stdlib.h>
------->	                  A
A: Warning W1000: Precede all headers with #define _POSIX_SOURCE

    293 	#include "cchk_missing_stdlib.h"       /* Workaround for Spurious CodeCheck diagnostic messages. */
    294 	#include <ctype.h>
    295 	#include <string.h>
    296 	#include <stdio.h>
    297 	#include <errno.h>		       /* perror() */
    298 	#include <unistd.h>
    299 	#include "cchk_missing_unistd.h"       /* Workaround for Spurious CodeCheck diagnostic messages. */
    300 	#include <signal.h>		       /* signal() */
    301 	#include "cchk_missing_signal.h"       /* Workaround for Spurious CodeCheck diagnostic messages. */
    302 	
    303 	#include <fcntl.h>		       /* open() */
    304 	#include <sys/types.h>		       /* mkfifo() */
    305 	#include <sys/stat.h>		       /* mkfifo() */
    306 	#include <errno.h>		       /* Operating system error condition definitions. */
    307 	
    308 	#include "semops.h"		       /* To create semaphore for the child process. */
    309 	#include "some_utils.h"		       /* util_abort() and growstr() utilities. */
    310 	#include "hash.h"		       /* Hash table to match process ID to a FIFO. */
    311 	#include "safe.h"		       /* sigpipe_handler() */
    312 	#include "fifo.h"
    313 	
    314 	static const    HASHTABLESIZ = 23;     /* There is nothing special about this value.  Use what works for you.  Increase the value
    315 					        * if performance drags down.  If that doesnt work, then change hash algorithm.  NOTE:
    316 					        * Prime numbers seem to make the best hash table sizes. */
    317 	
    318 	/*
    319 	 * FIFO_PRIVILEGES is a constant that specifies read/write privs on the FIFOs
    320 	 * Set owner-read, and owner-writee access on the FIFOs.  Note: Solaris 2
    321 	 * does not have symbolic names for these privileges.
    322 	 */
    323 	
    324 	#ifdef S_IRUSR
    325 	static const mode_t FIFO_PRIVILEGES = S_IRUSR | S_IWUSR;
    326 	
    327 	#else
      - 	static const mode_t FIFO_PRIVILEGES = 0600;
      - 	
    330 	#endif
    331 	
    332 	/*******************************************************************************
    333 	 * FUNCTION:	DUMP_SHAREDFIFO_STRUCT
    334 	 ******************************************************************************/
    335 	void            dump_sharedfifo_struct (FILE * fp, shared_fifodata_tt * parent2child)
    336 	{
    337 		fprintf (fp, "fd\t\t= %d\n", parent2child->fd);
    338 		fflush (fp);
    339 		fprintf (fp, "bufsiz\t= %d\n", parent2child->bufsiz);
    340 		fflush (fp);
    341 		fprintf (fp, "pathname\t= \"%s\"\n", parent2child->pathname ? parent2child->pathname : "(Null)");
    342 		fflush (fp);
    343 		fprintf (fp, "semaphore\t= %d\n", parent2child->semaphore);
    344 		fflush (fp);
    345 		fprintf (fp, "fromstr\t= \"%s\"\n", parent2child->fromstr ? parent2child->fromstr : "(Null)");
    346 		fflush (fp);
    347 		fprintf (fp, "data_gbuf\t= \"%s\"\n", parent2child->data_gbuf ? growbuf_str (parent2child->data_gbuf) : "(Null)");
    348 		fflush (fp);
    349 		fprintf (fp, "reply_htab\t= 0x%X\n", parent2child->reply_htab);
    350 		fflush (fp);
    351 	}
    352 	
    353 	/*******************************************************************************
    354 	 * FUNCTION:	DUMP_REPLYFIFO_STRUCT
    355 	 ******************************************************************************/
    356 	void            dump_replyfifo_struct (FILE * fp, reply_fifodata_tt * child2parent)
    357 	{
    358 		fprintf (fp, "pid\t= %d\n", child2parent->pid);
    359 		fflush (fp);
    360 		fprintf (fp, "childstr\t= \"%s\"\n", child2parent->childstr ? child2parent->childstr : "(Null)");
    361 		fflush (fp);
    362 		fprintf (fp, "fd\t\t= %d\n", child2parent->fd);
    363 		fflush (fp);
    364 		fprintf (fp, "bufsiz\t= %d\n", child2parent->bufsiz);
    365 		fflush (fp);
    366 		fprintf (fp, "pathname\t= \"%s\"\n", child2parent->pathname ? child2parent->pathname : "(Null)");
    367 		fflush (fp);
    368 		fprintf (fp, "data_gbuf\t= \"%s\"\n", child2parent->data_gbuf ? growbuf_str (child2parent->data_gbuf) : "(Null)");
    369 		fflush (fp);
    370 	}
    371 	
    372 	/*******************************************************************************
    373 	 * FUNCTION:	CREATE_NEW_FIFONAME
    374 	 *
    375 	 * PURPOSE:	Create a pathname suitable for use by mkfifo(), based on the
    376 	 *		process ID of the process that will read from the FIFO, and
    377 	 *		the process ID of the server process. ex:
    378 	 *		"prefix.server_pidstr.pidstr"
    379 	 ******************************************************************************/
    380 	static char    *create_new_fifoname (const shared_fifodata_tt * parent2child, const char *pidstr)
    381 	{
    382 	
    383 	/*
    384 	 * Allocate enough room for the name of the temporary directory (P_tmpdir),
    385 	 * the prefix string, a period, the length of the string representation of
    386 	 * the server process ID, another period, the string representation of the
    387 	 * callers process ID, and the NULL terminator. (the caller may be the
    388 	 * server, but does not have to be.
    389 	 */
    390 		const char     *prefix = "fifo";
    391 		char           *name = malloc (strlen (P_tmpdir) + strlen (prefix) + 1 + INTLEN + 1 + INTLEN + 1);
    392 	
    393 		if (name == NULL)
    394 		{
    395 			util_abort (__LINE__, __FILE__, "malloc() failed.\n");
    396 		}
    397 		sprintf (name, "%s%s.%s.%s", P_tmpdir, prefix, parent2child->server_pidstr, pidstr);
    398 	
    399 		return (name);
    400 	}
    401 	
    402 	/*******************************************************************************
    403 	 * FUNCTION: CREATE_FIFO
    404 	 *	Used to create either the parent2child FIFO, or the reply FIFOs.
    405 	 *	NOTE: the FIFO is not actually OPENED until AFTER a fork() operation.
    406 	 *	This means that parent and child processes will have different file
    407 	 *	descriptors for the fifo, and often open the FIFO in different modes,
    408 	 *	i.e. The parent may open for read/write, and the child open for
    409 	 *	write-only.  Opening for read/write prevents signals every time a
    410 	 *	child process close()es the FIFO -- useful when multiple children
    411 	 *	are writing to the FIFO.
    412 	 *
    413 	 *	NOTE: mkfifo() sets plain-jane "read write execute" type permissions.
    414 	 *	      DO NOT SET THESE PERMISSIONS in the subsequent call to open();
    415 	 *	      Give open() flags like readonly readwrite writeonly and
    416 	 *	      open for non-blocking IO.
    417 	 ******************************************************************************/
    418 	static void     create_fifo (const char *pathname)
    419 	{
    420 		if (mkfifo (pathname, FIFO_PRIVILEGES) == -1)
    421 		{
    422 			if (errno != EEXIST)   /* It is OK if the FIFO file object already exists. */
    423 			{
    424 				perror ("mkfifo()");
    425 				util_abort (__LINE__, __FILE__, "mkfifo() failed to create FIFO %s.\n", *pathname);
    426 			}
    427 		}
    428 	}
    429 	
    430 	/*******************************************************************************
    431 	 * FUNCTION:	INIT_PARENT2CHILD_FIFO
    432 	 *	NOTE: It is CRITICAL that you call this function BEFORE you fork()
    433 	 *	      off your client sub-processes.
    434 	 ******************************************************************************/
    435 	shared_fifodata_tt *init_parent2child_fifo (const char *pidstr)
    436 	{
    437 		static int      sigpipe_handler_registered = 0;	/* Set to nonzero after the SIGPIPE signal handler has been registered. */
    438 		shared_fifodata_tt *parent2child = (shared_fifodata_tt *) calloc (1, sizeof (shared_fifodata_tt));
    439 	
    440 		if (!sigpipe_handler_registered)
    441 		{
    442 			sigpipe_handler_registered = (!0);
    443 			signal (SIGPIPE, sigpipe_handler);
    444 		}
    445 	
    446 		if (parent2child == NULL)
    447 		{
    448 			util_abort (__LINE__, __FILE__, "calloc() failed.\n");
    449 		}
    450 		parent2child->semaphore = sem_create ();
    451 		strcpy (parent2child->server_pidstr, pidstr);
    452 		parent2child->pathname = create_new_fifoname (parent2child, pidstr);
    453 		create_fifo (parent2child->pathname);
    454 		parent2child->bufsiz = -1;	/* Not known until the FIFO is opened.  Set to an invalid value for now. */
    455 		parent2child->reply_htab = hash_new (HASHTABLESIZ);
    456 		parent2child->data_gbuf = NULL;
    457 	
    458 		return (parent2child);
    459 	}
    460 	
    461 	/*******************************************************************************
    462 	 * FUNCTION:	OPEN_FIFO
    463 	 *	Opens a FIFO and determines the buffer size.
    464 	 *
    465 	 * NOTE:
    466 	 *	Must be called AFTER fork(), because a process will block until there
    467 	 *	is another process on the other end of this FIFO.
    468 	 ******************************************************************************/
    469 	static int      open_fifo (const char *pathname, mode_t flags, int *bufsizptr)
    470 	{
    471 		int             fd = -1;       /* The CenterLine clcc compiler does not know that util_abort() halts execution, therefore
    472 					        * it generates a warning that "fd is possibly referenced before set."  I initialized fd
    473 					        * to suppress that warning message. */
    474 	
    475 		if ((fd = open (pathname, flags)) == -1)
    476 		{
    477 			perror ("open() in open_fifo()");
    478 			util_abort (__LINE__, __FILE__, "open(%s, 0%03o (octal)) failed to open a FIFO."
    479 				    " fd == %d; my PID == %d\n",
    480 				    pathname, flags, fd, getpid ());
    481 		}
    482 		*bufsizptr = fpathconf (fd, _PC_PIPE_BUF);	/* Get the buffer size for this particular FIFO. */
    483 	
    484 		fflush (stdout);
    485 	
    486 		if (*bufsizptr == -1)
    487 		{
    488 			perror ("fpathconf()");
    489 			util_abort (__LINE__, __FILE__, "pathconf() failed to return the buffer size for FIFO %s.\n"
    490 				    "parent2child->bufsiz == %d\n", *bufsizptr, pathname);
    491 		}
    492 		return (fd);
    493 	}
    494 	
    495 	/*******************************************************************************
    496 	 * FUNCTION:	OPEN_PARENT2CHILD_FIFO
    497 	 *	Both the parent (server) process, and all child processes will call
    498 	 *	this function.  Parent will pass flags to open for read only(O_RDONLY),
    499 	 * 	and child processes will open for write-only (O_WRONLY).
    500 	 *
    501 	 *	NOTE: In the end-user code, only the SERVER process will directly call
    502 	 *	      this function.  The end-user CLIENT code calls this function
    503 	 *	      indirectly, by calling connect_to_parent().
    504 	 ******************************************************************************/
    505 	void            open_parent2child_fifo (shared_fifodata_tt * parent2child, mode_t flags)
    506 	{
    507 		parent2child->fd = open_fifo (parent2child->pathname, flags, &parent2child->bufsiz);
    508 	}
    509 	
    510 	/*******************************************************************************
    511 	 * FUNCTION:	PARENT_OPEN_REPLY_FIFO
    512 	 *	Called from the server (parent) process, when the server process
    513 	 *	receives a SRV_CONNECT message.
    514 	 ******************************************************************************/
    515 	void            parent_open_reply_fifo (shared_fifodata_tt * parent2child, const char *child_pidstr)
    516 	{
    517 		reply_fifodata_tt *child2parent = (reply_fifodata_tt *) calloc (1, sizeof (reply_fifodata_tt));
    518 	
    519 		if (child2parent == NULL)
    520 		{
    521 			util_abort (__LINE__, __FILE__, "calloc() failed.\n");
    522 		}
    523 		child2parent->pid = atoi (child_pidstr);
    524 	
    525 	/* Check to see if it has already been created and added to the hash table. */
    526 		if (!hash_find (parent2child->reply_htab, child2parent->pid))
    527 		{
    528 		/* make fifo, initialize fields, open fifo */
    529 			child2parent->pathname = create_new_fifoname (parent2child, child_pidstr);
    530 			child2parent->fd = open_fifo (child2parent->pathname, O_WRONLY, &child2parent->bufsiz);
    531 	
    532 			hash_add (parent2child->reply_htab, child2parent);
    533 		}
    534 		else
    535 		{
    536 			free (child2parent);	/* A node for this childs reply FIFO already existed in the hash table. */
    537 			fprintf (stderr, "Warning: line %d of %s.  You have already created a reply FIFO for child pid %s.\n",
    538 				 __LINE__, __FILE__, child_pidstr);
    539 		}
    540 	}
    541 	
    542 	/*******************************************************************************
    543 	 * FUNCTION:	SEND2PARENT
    544 	 ******************************************************************************/
    545 	void            send2parent (shared_fifodata_tt * parent2child, server_command_tt command, const char *dataptr)
    546 	{
    547 	
    548 	/*
    549 	 * header_string contains three integer strings delimited by 3 spaces, ending
    550 	 * with a NULL terminator.
    551 	 */
    552 		char            header_string[INTLEN + 1 + INTLEN + 1 + INTLEN + 1 + 1];
    553 		static growbuf_tt *gbuf = NULL;/* A buffer which grows as you append data to it.  It grows to the size of the longest
    554 					        * data stream copied to it. */
    555 		size_t          sendsize;
    556 		size_t          bytes_left;
    557 		size_t          bytes_sent;
    558 	
    559 		if (gbuf == NULL)	/* First call to this function. */
    560 		{
    561 			growbuf_init (&gbuf);
    562 		}
    563 	/* Note: the space after the third number is required later by sscanf(). */
    564 		sprintf (header_string, "%*d %*d %*d ", INTLEN, getpid (), INTLEN, command, INTLEN, strlen (dataptr));
    565 	
    566 		growbuf_strcpy (gbuf, header_string);
    567 		growbuf_strcat (gbuf, dataptr);
    568 	
    569 		sem_wait (parent2child->semaphore);	/* You can get interleaved writes from different child processes if you need to
    570 							 * send more bytes than can be written in a single atomic write to a FIFO. */
    571 		bytes_left = strlen (growbuf_str (gbuf));	/* Length EXCLUDES header length. */
    572 		while (bytes_left)
    573 		{
    574 			if (bytes_left > parent2child->bufsiz)
    575 			{
    576 				sendsize = parent2child->bufsiz;
    577 			}
    578 			else
    579 			{
    580 				sendsize = bytes_left;
    581 			}
    582 			bytes_sent = write (parent2child->fd, growbuf_str (gbuf), sendsize);
    583 			if (sendsize != bytes_sent)
    584 			{
    585 				perror ("write() in send2parent()");
    586 				printf ("*---- Only able to write %d bytes.  Requested size = %d.  Line %d of %s ----*\n",
    587 					bytes_sent, sendsize, __LINE__, __FILE__);
    588 				fflush (stdout);
    589 				if (bytes_sent < 0)
    590 					bytes_sent = 0;
    591 			}
    592 			bytes_left -= bytes_sent;
    593 		}
    594 		sem_signal (parent2child->semaphore);
    595 		return;
    596 	}
    597 	
    598 	/*******************************************************************************
    599 	 *FUNCTION:	SEND2CHILD
    600 	 *	NOTE: The sender simply echos the "command" token it received back to
    601 	 *	the child.   I did this to keep all message headers the same.
    602 	 *
    603 	 *	This function needs the parent2child struct, so it can look up the
    604 	 *	reply FIFO in the hash table of reply nodes.
    605 	 ******************************************************************************/
    606 	void            send2child (shared_fifodata_tt * parent2child, const char *child_pidstr,
    607 				                    server_command_tt command, const char *dataptr)
    608 	{
    609 		char            header_string[INTLEN + 1 + INTLEN + 1 + INTLEN + 1 + 1];
    610 		static growbuf_tt *gbuf = NULL;/* A buffer which grows as you append data to it.  It grows to the size of the longest
    611 					        * data stream copied to it. */
    612 		size_t          sendsize;
    613 		size_t          bytes_left;
    614 		size_t          bytes_sent;
    615 		reply_fifodata_tt *child2parent;
    616 		int             hashkey;
    617 	
    618 		hashkey = atoi (child_pidstr);
    619 		child2parent = (reply_fifodata_tt *) hash_find (parent2child->reply_htab, hashkey);
    620 		if (child2parent == NULL)
    621 		{
    622 			util_abort (__LINE__, __FILE__, "The reply_fifodata_tt struct pointer, for Child pid %s was not "
    623 				    "in the parent2child->reply_htab hash table.  hashkey == %d\n",
    624 				    child_pidstr ? child_pidstr : "(Null String)", hashkey);
    625 		}
    626 	
    627 		if (gbuf == NULL)	/* First call to this function. */
    628 		{
    629 			growbuf_init (&gbuf);
    630 		}
    631 	/* Note: the space after the third number is required later by sscanf(). */
    632 		sprintf (header_string, "%*d %*d %*d ", INTLEN, getpid (), INTLEN, command, INTLEN, strlen (dataptr));
    633 	
    634 		growbuf_strcpy (gbuf, header_string);
    635 		growbuf_strcat (gbuf, dataptr);
    636 	
    637 		bytes_left = strlen (growbuf_str (gbuf));	/* Length EXCLUDES header length. */
    638 		while (bytes_left)
    639 		{
    640 			if (bytes_left > child2parent->bufsiz)
    641 			{
    642 				sendsize = child2parent->bufsiz;
    643 			}
    644 			else
    645 			{
    646 				sendsize = bytes_left;
    647 			}
    648 	
    649 			bytes_sent = write (child2parent->fd, growbuf_str (gbuf), sendsize);
    650 			if (sendsize != bytes_sent)
    651 			{
    652 				perror ("write() in send2child()");
    653 				printf ("*---- Process %d only able to write %d bytes.  Requested size = %d.  Line %d of %s ----*\n",
    654 					getpid (), bytes_sent, sendsize, __LINE__, __FILE__);
    655 				fflush (stdout);
    656 				if (bytes_sent < 0)
    657 					bytes_sent = 0;
    658 			}
    659 			bytes_left -= bytes_sent;
    660 		}
    661 		return;
    662 	}
    663 	
    664 	/*******************************************************************************
    665 	 * FUNCTION:	CONNECT_TO_PARENT
    666 	 *	Called from child processes.  You only want to call this function once
    667 	 *	for each connection opened to an ancestor process.  Note that it is
    668 	 *	possible that you would want to connect to your mother process and
    669 	 *	your grandmother process.
    670 	 *	1. Allocate a child2parent struct, and fill in the childstr and
    671 	 *	   pathname filelds
    672 	 *	2. Get a pathname for, and create the FIFO in the file system and open it
    673 	 *	   (by calling open_parent2child_fifo())
    674 	 *	3. Open the shared fifo for writing.
    675 	 *	4. Tell the server to create a reply fifo.
    676 	 *	5. Open the reply fifo for reading.
    677 	 ******************************************************************************/
    678 	void            connect_to_parent (shared_fifodata_tt * parent2child, const char *pidstr, reply_fifodata_tt ** child2parent)
    679 	{
    680 		char            message[128];
    681 	
    682 		*child2parent = (reply_fifodata_tt *) calloc (1, sizeof (reply_fifodata_tt));
    683 		if (child2parent == NULL)
    684 		{
    685 			util_abort (__LINE__, __FILE__, "calloc() failed.\n");
    686 		}
    687 		strcpy ((*child2parent)->childstr, pidstr);
    688 		(*child2parent)->pathname = create_new_fifoname (parent2child, pidstr);
    689 		create_fifo ((*child2parent)->pathname);
    690 		open_parent2child_fifo (parent2child, O_WRONLY);
    691 		sprintf (message, "This is an SRV_CONNECT message.");
    692 		send2parent (parent2child, SRV_CONNECT, message);
    693 		(*child2parent)->fd = open_fifo ((*child2parent)->pathname, O_RDONLY, &(*child2parent)->bufsiz);
    694 	}
    695 	
    696 	/*******************************************************************************
    697 	 * FUNCTION:	DESTROY_CHILD2PARENT
    698 	 *	Each child process allocates memory for handling the reply FIFO, in
    699 	 *	its own address space.  Unlink the child2parent FIFOs in the file
    700 	 *	system from the parent process.
    701 	 ******************************************************************************/
    702 	void            destroy_child2parent (reply_fifodata_tt * child2parent)
    703 	{
    704 		/*** printf ("destroy_child2parent( 0x%X ) called by PID %d\n", child2parent, getpid ()); ***/
    705 		/*** fflush (stdout); ***/
    706 		if (child2parent != NULL)
    707 		{
    708 			close (child2parent->fd);
    709 			if (child2parent->pathname)
    710 			{
    711 				free (child2parent->pathname);
    712 			}
    713 			if (child2parent->data_gbuf != NULL)
    714 			{
    715 				growbuf_free (&(child2parent->data_gbuf));
    716 			}
    717 		}
    718 	}
    719 	
    720 	/*******************************************************************************
    721 	 * FUNCTION:	DESTROY_FIFOS
    722 	 *	This function cannot destroy the reply FIFO data structures created by
    723 	 *	child processes, because those data structures are in another
    724 	 *	address space.
    725 	 ******************************************************************************/
    726 	void            destroy_fifos (shared_fifodata_tt * parent2child)
    727 	{
    728 		reply_fifodata_tt *child2parent;
    729 		void           *pos;	       /* A context reference used by hash_getfirst() and hash_getnext() */
    730 	
    731 		/*** printf ("destroy_fifos() is blasting the following:\nShared parent FIFO:\n"); ***/
    732 		/*** dump_sharedfifo_struct (stdout, parent2child); ***/
    733 		/*** printf ("\nChild FIFOs:\n"); ***/
    734 	
    735 	/* Remove the parent FIFO from the file system. */
    736 		close (parent2child->fd);
    737 		unlink (parent2child->pathname);
    738 	
    739 	/*
    740 	 * Destroy the data items referenced by each child2parent struct in the hash
    741 	 * table.  Use hash_free() to destroy the child2parent nodes themselves
    742 	 * (hash_free calls free() on the data pointers for each hash table entry.)
    743 	 * Do not forget to unlink() the child2parent FIFOs from the file system.
    744 	 */
    745 		child2parent = (reply_fifodata_tt *) hash_getfirst (&pos, parent2child->reply_htab);
    746 		if (child2parent != NULL)
    747 		{
    748 			/*** dump_replyfifo_struct (stdout, child2parent); ***/
    749 			/*** printf ("\n"); ***/
    750 			unlink (child2parent->pathname);
    751 			destroy_child2parent (child2parent);
    752 			while ((child2parent = (reply_fifodata_tt *) hash_getnext (&pos, parent2child->reply_htab)) != NULL)
    753 			{
    754 				/*** dump_replyfifo_struct (stdout, child2parent); ***/
    755 				/*** printf ("\n"); ***/
    756 				unlink (child2parent->pathname);
    757 				destroy_child2parent (child2parent);
    758 			}
    759 		}
    760 		hash_free (parent2child->reply_htab);
    761 	
    762 	/* Free the rest of the data fields */
    763 		free (parent2child->pathname);
    764 		if (parent2child->data_gbuf)
    765 		{
    766 			growbuf_free (&parent2child->data_gbuf);
    767 		}
    768 	
    769 	/* Free the shared fifo struct itself. */
    770 		free (parent2child);
    771 	}
    772 	
    773 	/*******************************************************************************
    774 	 * FUNCTION:	READ_HEADER
    775 	 *	Reads the fixed-lengtn message header, which contains the PID of process
    776 	 *	sending the message, a "command" value from the enumerated type
    777 	 *	server_command_tt, and the length of the text of the message which
    778 	 *	follows the header.
    779 	 *
    780 	 *	This function tries to recover from interrupted calls to read().
    781 	 ******************************************************************************/
    782 	static void     read_header (int fd, const char *sender_pidstr, server_command_tt * command, size_t * msglen)
    783 	{
    784 		char            buf[MSG_HEADER_SIZ + 1];
    785 		size_t          recvsize;
    786 		size_t          bytes_read = 0;
    787 		int             num_translations;	/* Number of fields successfully translated by sscanf(). */
    788 		int             retry_count = 10;	/* Maximum number of read attempts before giving up. */
    789 	
    790 		buf[MSG_HEADER_SIZ] = '\0';
    791 		do
    792 		{
    793 			if (bytes_read)
    794 			{
    795 				printf ("Attempting follow-up read.  bytes_read == %d\n", bytes_read);
    796 			}
    797 	
    798 			if ((recvsize = read (fd, &buf[bytes_read], MSG_HEADER_SIZ)) == -1)
    799 			{
    800 				if (errno == EINTR)	/* Caught an interrupt? no problem, just try again. */
    801 				{
    802 					recvsize = 0;
    803 				}
    804 				else
    805 				{
    806 					perror ("read() in read_header()");
    807 					util_abort (__LINE__, __FILE__, "Process %d failed to read a message header.\n"
    808 						    "read (%d, 0x%X, %d); errno == %d\n", getpid (), fd, buf, MSG_HEADER_SIZ, errno);
    809 				}
    810 			}
    811 			bytes_read += recvsize;
    812 			if (bytes_read < MSG_HEADER_SIZ)
    813 			{
    814 				printf ("Partial read(): retries left %d; bytes_read %d; process %d\n"
    815 					"\trecvsize %d, header size %d; line %d of %s.\n",
    816 					retry_count, bytes_read, getpid (), recvsize, MSG_HEADER_SIZ, __LINE__, __FILE__);
    817 				fflush (stdout);
    818 				--retry_count;
    819 				if (!retry_count)
    820 					abort ();
    821 	
    822 			}
    823 			if (strlen (buf) == 0)
    824 			{
    825 				if (bytes_read > 0)
    826 				{
    827 	
    828 				/*
    829 				 * On the HP, if a write() operation gets
    830 				 * interrupted, you still get a NULL char on the
    831 				 * receiving end.
    832 				 */
    833 					int             idx;
    834 					int             shiftcount;
    835 	
    836 					printf ("Zero length read, but read() returned nonzero.  errno = %d\n"
    837 						"\tretries left %d: bytes_read %d; process %d\n"
    838 						"\trecvsize %d, header size %d; line %d of %s.\n",
    839 						errno, retry_count, bytes_read, getpid (), recvsize, MSG_HEADER_SIZ, __LINE__, __FILE__);
    840 					printf ("Contents of buf[]:\n");
    841 					for (idx = 0; idx < MSG_HEADER_SIZ; idx++)
    842 					{
    843 						printf ("buf [%2d] = '%c' == %d  == Ox%X\n", idx, buf[idx], buf[idx], buf[idx]);
    844 					}
    845 					fflush (stdout);
    846 	
    847 					--retry_count;
    848 					if (!retry_count)
    849 						abort ();
    850 	
    851 				/*
    852 				 * On the HP, if a write() operation gets
    853 				 * interrupted, you get an extraneous NULL char in
    854 				 * the data stream, that the reader has to throw
    855 				 * away.
    856 				 */
    857 	
    858 					shiftcount = 0;
    859 					while ((buf[0] == '\0') && (shiftcount < MSG_HEADER_SIZ))
    860 					{
    861 						for (idx = 0; idx < (MSG_HEADER_SIZ - shiftcount); ++idx)
    862 						{
    863 							buf[idx] = buf[idx + 1];
    864 						}
    865 						++shiftcount;
    866 					}
    867 					bytes_read -= shiftcount;
    868 					buf[MSG_HEADER_SIZ] = '\0';
    869 					printf ("buf[] after shift: \"%s\"\n\tbytes_read = %d; shiftcount = %d\n", buf, bytes_read, shiftcount);
    870 					fflush (stdout);
    871 				}
    872 			}
    873 		} while (bytes_read < MSG_HEADER_SIZ);
    874 		buf[bytes_read] = '\0';
    875 		num_translations = sscanf (buf, "%s %d %d ", sender_pidstr, command, msglen);
    876 	
    877 		if (num_translations < 3)
    878 		{
    879 			util_abort (__LINE__, __FILE__, "sscanf() failed to translate the following message header:"
    880 				    "\t\"%s\"\nOnly %d translations were made.\n", buf, num_translations);
    881 		}
    882 	}
    883 	
    884 	/*******************************************************************************
    885 	 * FUNCTION:	read_msgtext
    886 	 ******************************************************************************/
    887 	static int      read_msgtext (int fd, int bufsiz, size_t msglen, growbuf_tt * gbuf)
    888 	{
    889 		static int      buflen = 0;
    890 		size_t          recvsize;
    891 		int             bytes_read = 0;
    892 		int             bytes2go;
    893 		static char    *buf = NULL;
    894 	
    895 		if (buf == NULL)
    896 		{
    897 			buflen = bufsiz + 1;
    898 			if ((buf = calloc (buflen, sizeof (char))) == NULL)
    899 			{
    900 				perror ("calloc()");
    901 				util_abort (__LINE__, __FILE__, "calloc(%d, %d) failed.\n", buflen, sizeof (char));
    902 			}
    903 		}
    904 	
    905 		growbuf_strcpy (gbuf, "");
    906 		bytes_read = 0;
    907 	
    908 		while ((bytes_read < msglen))
    909 		{
    910 			bytes2go = msglen - bytes_read;
    911 			if (bytes2go < bufsiz)
    912 				recvsize = bytes2go;
    913 			else
    914 				recvsize = bufsiz;
    915 			if ((recvsize = read (fd, buf, recvsize)) == -1)
    916 			{
    917 				if (errno == EINTR)	/* Caught an interrupt? no problem, just try again. */
    918 				{
    919 					recvsize = 0;
    920 				}
    921 				else
    922 				{
    923 					perror ("read() in read_msgtext()");
    924 					util_abort (__LINE__, __FILE__, "Process %d failed calling read(%d, 0x%X, %d)\n",
    925 						    getpid (), fd, buf, recvsize);
    926 				}
    927 			}
    928 			bytes_read += recvsize;
    929 			buf[bytes_read] = '\0';
    930 			growbuf_strcat (gbuf, buf);
    931 		}
    932 		return (bytes_read);
    933 	}
    934 	
    935 	/*******************************************************************************
    936 	 * FUNCTION:	RECEIVE_FM_PARENT
    937 	 *	1. Find out a)who is sending the message, b)what kind of message it
    938 	 *	   is, and c) how big the message is.
    939 	 *	2. Make sure your buffer object has been initialized.
    940 	 *	3. Fetch the actual text of the message, pass back the message size via
    941 	 *	   the datalen_ptr parameter.
    942 	 *	3. Pass back a pointer to the message via the dataptr parameter.
    943 	 *	4. Return the message type/command to the caller.
    944 	 ******************************************************************************/
    945 	server_command_tt receive_fm_parent (reply_fifodata_tt * child2parent, size_t * datalen_ptr)
    946 	{
    947 		server_command_tt command;
    948 		size_t          msglen;
    949 		char            sender_pidstr[INTLEN + 1];
    950 	
    951 		read_header (child2parent->fd, sender_pidstr, &command, &msglen);
    952 		if (child2parent->data_gbuf == NULL)
    953 		{
    954 			growbuf_init (&child2parent->data_gbuf);
    955 		}
    956 	
    957 		*datalen_ptr = read_msgtext (child2parent->fd, child2parent->bufsiz, msglen, child2parent->data_gbuf);
    958 		return (command);
    959 	}
    960 	
    961 	/*******************************************************************************
    962 	 * FUNCTION:	RECEIVE_FM_CHILD
    963 	 *	Read a complete message from the shared FIFO.  Return the command
    964 	 *	value to the caller.  Pass the string representation of the message,
    965 	 *	a pointer to the text of the message, and the length of the message
    966 	 *	text (EXCLUDING the header length) to the caller.
    967 	 ******************************************************************************/
    968 	server_command_tt receive_fm_child (shared_fifodata_tt * parent2child, char child_pidstr[INTLEN], size_t * datalenptr)
    969 	{
    970 		server_command_tt command;     /* Return value. */
    971 		size_t          msgsize;
    972 	
    973 		read_header (parent2child->fd, child_pidstr, &command, &msgsize);
    974 	
    975 		if (parent2child->data_gbuf == NULL)	/* First read from the shared FIFO. */
    976 		{
    977 			growbuf_init (&parent2child->data_gbuf);
    978 		}
    979 		growbuf_strcpy (parent2child->data_gbuf, "");
    980 	
    981 		*datalenptr = read_msgtext (parent2child->fd, parent2child->bufsiz, msgsize, parent2child->data_gbuf);
    982 	
    983 		return (command);
    984 	}				       /* end receive_fm_child() */
    985 	
    986 	/*******************************************************************************
    987 	 * FUNCTION:	REPLY_FIFO_BUFSIZ
    988 	 *	The size of the FIFO buffer may depend on the device on which it
    989 	 *	was created.
    990 	 ******************************************************************************/
    991 	int             reply_fifo_bufsiz (reply_fifodata_tt * child2parent)
    992 	{
    993 		return (child2parent->bufsiz);
    994 	}
    995 	
    996 	/*******************************************************************************
    997 	 * FUNCTION:	REPLY_FIFO_DATA
    998 	 *	NOTE: this function returns a pointer to storage inside the FIFO
    999 	 *	      modules internal data structures; so give the caller a pointer
   1000 	 *	      that cannot be written to (const).  If the caller wants to
   1001 	 *	      modify the data, then it must make its own copy.  (this internal
   1002 	 *	      data is overwritten whenever a read() is perfomed on the FIFO
   1003 	 *	      anyway).
   1004 	 ******************************************************************************/
   1005 	const char     *reply_fifo_data (reply_fifodata_tt * child2parent)
   1006 	{
   1007 		return (growbuf_str (child2parent->data_gbuf));
   1008 	}
   1009 	
   1010 	/*******************************************************************************
   1011 	 * FUNCTION:	SHARED_FIFO_BUFSIZ
   1012 	 *	The size of the FIFO buffer may depend on the device on which it
   1013 	 *	was created.
   1014 	 ******************************************************************************/
   1015 	int             shared_fifo_bufsiz (shared_fifodata_tt * parent2child)
   1016 	{
   1017 		return (parent2child->bufsiz);
   1018 	}
   1019 	
   1020 	/*******************************************************************************
   1021 	 * FUNCTION:	SHARED_FIFO_DATA
   1022 	 *	NOTE: this function returns a pointer to storage inside the FIFO
   1023 	 *	      modules internal data structures; so give the caller a pointer
   1024 	 *	      that cannot be written to (const).  If the caller wants to
   1025 	 *	      modify the data, then it must make its own copy.  (this internal
   1026 	 *	      data is overwritten whenever a read() is perfomed on the FIFO
   1027 	 *	      anyway).
   1028 	 ******************************************************************************/
   1029 	const char     *shared_fifo_data (shared_fifodata_tt * parent2child)
   1030 	{
   1031 		return (growbuf_str (parent2child->data_gbuf));
   1032 	}
   1033 	
   1034 	/*******************************************************************************
   1035 	 * FUNCTION:	COMMANDVAL2STRING
   1036 	 *	Returns a pointer to the string representation of an element of the
   1037 	 *	enumerated type "server_command_tt".
   1038 	 ******************************************************************************/
   1039 	typedef struct server_command_lookup_ss
   1040 	{
   1041 		server_command_tt enum_val;
   1042 		const char     *valstr;
   1043 	}               server_command_lookup_tt;
   1044 	
   1045 	const char     *commandval2string (server_command_tt val)
   1046 	{
   1047 		static server_command_lookup_tt lookup_table[] = {
   1048 			SRV_CONNECT, "SRV_CONNECT",
   1049 			SRV_PRINT, "SRV_PRINT",
   1050 			SRV_TIMEOUT, "SRV_TIMEOUT",
   1051 			SRV_ECHO, "SRV_ECHO",
   1052 			SRV_POPUP_ERROR_DIALOG, "SRV_POPUP_ERROR_DIALOG",
   1053 			SRV_DRAW_LINE, "SRV_DRAW_LINE",
   1054 			SRV_COPY_AREA, "SRV_COPY_AREA",
   1055 			SRV_DRAW_STRING, "SRV_DRAW_STRING",
   1056 			SRV_DISPLAY_EXEC_MSG, "SRV_DISPLAY_EXEC_MSG",
   1057 			SRV_BELL, "SRV_BELL",
   1058 			SRV_BLINK, "SRV_BLINK",
   1059 			SRV_SHUTDOWN, "SRV_SHUTDOWN"
   1060 		};
   1061 	
   1062 		if (val != lookup_table[(int) val].enum_val)
   1063 		{
   1064 			util_abort (__LINE__, __FILE__, "The lookup table for translating values from the enumerated type \n"
   1065 				    "\"server_command_tt\" into character strings, is out of order.   Compare the \n"
   1066 				    "definition of type server_command_tt in fifo.h, to the lookup table in\n"
   1067 				    "commandval2string().  Value %d incorrectly maps to the string representation \n"
   1068 				    "for value %d (\"%s\")\n", val, lookup_table[(int) val].enum_val, lookup_table[(int) val].valstr);
   1069 		}
   1070 	
   1071 		return (lookup_table[(int) val].valstr);
   1072 	}



Checking extended ANSI C file hash.c with rules from ansi.cc, posix.cc:

      1 	/*******************************************************************************
      2 	 * I borrowed the hash table utilities from Ethan Solomitas xmove program.  This
      3 	 * source is covered by a copyright that pretty much allows free use
      4 	 * (see below).
      5 	 *
      6 	 * NOTE: I added compute_hash(), but DID NOT USE IT.  I was hashing on process
      7 	 *	 IDs of fork()ed child processes, which tend to be sequential.  These
      8 	 *	 lend themselves to successful hashing by a trivial modulo operation.
      9 	 *
     10 	 *	 If you want to use compute_hash(), you will have to change the assumed
     11 	 *	 key from an integer to a string, and call compute_hash from within
     12 	 *	 the hash routines.  If you compute the hash function value, and then
     13 	 *	 store it as your key, the hash table functions will not be able to
     14 	 *	 tell the difference between a duplicated entry (because you are no-
     15 	 *	 longer storing the original key), and a hash function collision.
     16 	 *
     17 	 * I found this source on src.doc.ic.ac.uk in directory:
     18 	 * /computing/graphics/systems/X11/pub/R6untarred/contrib/programs/xmove/xmove
     19 	 *
     20 	 * --Malcolm /24/94
     21 	 *******************************************************************************
     22 	 *                            xmove
     23 	 *                            -----
     24 	 *             A Pseudoserver For Client Mobility
     25 	 *
     26 	 *   Copyright (c) 1994         Ethan Solomita
     27 	 *
     28 	 *   The X Consortium, and any party obtaining a copy of these files from
     29 	 *   the X Consortium, directly or indirectly, is granted, free of charge, a
     30 	 *   full and unrestricted irrevocable, world-wide, paid up, royalty-free,
     31 	 *   nonexclusive right and license to deal in this software and
     32 	 *   documentation files (the "Software"), including without limitation the
     33 	 *   rights to use, copy, modify, merge, publish, distribute, sublicense,
     34 	 *   and/or sell copies of the Software, and to permit persons who receive
     35 	 *   copies from any such party to do so.  This license includes without
     36 	 *   limitation a license to do the foregoing actions under any patents of
     37 	 *   the party supplying this software to the X Consortium.
     38 	 *******************************************************************************
     39 	 * $Date: 1994/08/04 17:59:15 $
     40 	 * $State: Exp $
     41 	 * $Locker:  $
     42 	 * $Source: /all/franklin/thesis/descartes/win/RCS/hash.c,v $
     43 	 *
     44 	 ******************************************************************************/
     45 	
     46 	#if 0
      - 	/******************************************************************************
      - 	 *
      - 	$Log: hash.c,v $
      - 	 * Revision 1.6  1994/08/04  17:59:15  franklin
      - 	 * Add #includes for cchk_missing_<standard include>.h in order
      - 	 * to get prototypes that CodeCheck doesnt think are there.
      - 	 *
      - 	 * Revision 1.5  1994/08/03  21:55:53  franklin
      - 	 * Changed "str" to "pstr"; prefix "str" is reserved by string.h
      - 	 *
      - 	 * Revision 1.4  1994/08/01  18:35:00  franklin
      - 	 * I decided not to use compute_hash() after all.  I simply left in in
      - 	 * this file in case someone else needs it in the future, to build a
      - 	 * hash table utility based on character string keys, rather than
      - 	 * integers.
      - 	 *
      - 	 * Also ran it through indent.
      - 	 *
      - 	 * Revision 1.3  1994/07/29  15:49:47  franklin
      - 	 * Add new hashing algorithm, compute_hash().
      - 	 *
      - 	 * Revision 1.2  1994/07/25  00:13:11  franklin
      - 	 * hash_add() and hash_free() really dont return useful values.  Make them void.
      - 	 *
      - 	 * Revision 1.1  1994/07/24  23:02:33  franklin
      - 	 * Initial revision
      - 	 *
      - 	 ******************************************************************************/
     75 	#endif
     76 	static char    *rcsid = "@(#) $Id: hash.c,v 1.6, h4_3_8, h4_3_7, h4_3_6, h4_3_5, h4_3_4 1994/08/04 17:59:15 franklin Exp $";
     77 	
     78 	#include <stdlib.h>
------->	                  A
A: Warning W1000: Precede all headers with #define _POSIX_SOURCE

     79 	#include "cchk_missing_stdlib.h"        /* Workaround for Spurious CodeCheck diagnostic messages. */
     80 	#include <limits.h>
     81 	#include <string.h>
     82 	#include <stdio.h>
     83 	#include "hash.h"
     84 	
     85 	/*******************************************************************************
     86 	 * FUNCTION:	COMPUTE_HASH
     87 	 *	For best results, use a prime-number for the hash table size.  The hash
     88 	 *	table size is stored inside the hash table header struct.
     89 	 *
     90 	 * NOTE:	The hash_table pointer is a parameter, so that you can have
     91 	 *		multiple hash tables of differering sizes in your program.
     92 	 *
     93 	 *		THIS FUNCTION WAS NOT USED IN MALCOLM FRANKLINS VERSION OF THE
     94 	 *		DESCARTES LANGUAGE PROCESSOR.  I only left it here in case
     95 	 *		someone in the future wanted to compute a hash value based on
     96 	 *		a string key.
     97 	 *
     98 	 * RETURNS:	An integer, because the hash table functions expect an int.
     99 	 *		Personally, I would have used an unsigned int, but I did not
    100 	 *		want to run the risk of injecting new bugs into code that
    101 	 *		probably works.
    102 	 *
    103 	 * AUTHOR:	Malcolm L. Franklin, Arizona State University
    104 	 ******************************************************************************/
    105 	
    106 	int             compute_hash (char *pstr, hash_table * table)
    107 	{
    108 		int             idx;
    109 		unsigned int    hash = 0;
    110 		static int      bits_per_int;
    111 		static const int SHIFTNUM = 7; /* This value seemed to work best for string representations of integers. */
    112 	
    113 	/*
    114 	 * On the first call to this function, find out how many bits there are in an
    115 	 * integer for this machine.
    116 	 */
    117 		if (bits_per_int == 0)
    118 		{
    119 			unsigned int    bits_to_go = UINT_MAX;
    120 	
    121 			while (bits_to_go)
    122 			{
    123 				++bits_per_int;
    124 				bits_to_go >>= 1;
    125 			}
    126 		}
    127 	
    128 		if (pstr)		/* Null pointer protection */
    129 		{
    130 			memcpy (&hash, pstr, sizeof (int));
    131 	
    132 		/*
    133 		 * printf("hash before loop  = %11d ", hash); dump_bits (stdout,
    134 		 * hash);printf("\n");fflush(stdout);
    135 		 */
    136 			idx = 0;
    137 			while (*pstr && (idx < sizeof (int)))
    138 			{
    139 			/* Rotate, not just shift, the bits in hash */
    140 				hash = (hash << SHIFTNUM) |
    141 					((hash >> bits_per_int - SHIFTNUM) & ((1 << SHIFTNUM) -1));
    142 	
    143 			/*
    144 			 * printf("hash after rot = "); dump_bits (stdout,
    145 			 * hash);printf("\n");fflush(stdout);
    146 			 */
    147 	
    148 				hash ^= *pstr;
    149 				++pstr;
    150 				++idx;
    151 			}
    152 		}
    153 		if ((int) hash < 0)
    154 			return (-hash % table->len);
    155 		else
    156 			return (hash % table->len);
    157 	}				       /* end compute_hash */
    158 	
    159 	/*
    160 	 * here we implement the functions described in hash.h. hash_new and and
    161 	 * hash_delete create and destroy tables. All structures are allocated
    162 	 * dynamically using malloc, so the proc that called hash_new can exit. A
    163 	 * pointer is returned from hash_new with the address of the new table.
    164 	 * 
    165 	 * When the table is freed, all hash_entry->data's will be free()'d. hash_delete
    166 	 * also expects that no one else is either currently accessing the table or
    167 	 * will try to access the table in the future. hash_delete does *not* free()
    168 	 * the data, but returns it instead.
    169 	 * 
    170 	 * The "key" for a hash_entry is the first sizeof(int) bytes of the data pointed
    171 	 * to by hash_entry->data.
    172 	 * 
    173 	 * hash_find can be used to change data, since it returns the actual ptr.
    174 	 * 
    175 	 */
    176 	
    177 	/*******************************************************************************
    178 	 * FUNCTION:	HASH_NEW
    179 	 ******************************************************************************/
    180 	hash_table     *hash_new (int len)
    181 	{
    182 		hash_table     *table;
    183 	
    184 		table = (hash_table *) malloc (sizeof (hash_table));
    185 		if (table == NULL)
    186 			return NULL;
    187 	
    188 		table->len = len;
    189 		table->table = (hash_entry *) calloc (len, sizeof (hash_entry));
    190 		table->ordered_last = NULL;
    191 	
    192 		if (table->table == NULL)
    193 		{
    194 			free (table);
    195 			return NULL;
    196 		}
    197 	
    198 		return table;
    199 	}
    200 	
    201 	/*******************************************************************************
    202 	 * FUNCTION:	HASH_FREE
    203 	 ******************************************************************************/
    204 	void            hash_free (hash_table * table)
    205 	{
    206 		hash_entry     *cur,
    207 		               *curlist,
    208 		               *next;
    209 	
    210 		for (cur = table->table; cur < (table->table + table->len); cur++)
    211 		{
    212 			if (cur->data)
    213 				free (cur->data);
    214 	
    215 			next = cur->next;
    216 			while (next)
    217 			{
    218 				curlist = next;
    219 				if (curlist->data)
    220 					free (curlist->data);
    221 	
    222 				next = curlist->next;
    223 				free (curlist);
    224 			}
    225 		}
    226 	
    227 		free (table->table);
    228 		free (table);
    229 	}
    230 	
    231 	/*******************************************************************************
    232 	 * FUNCTION:	HASH_ADD
    233 	 ******************************************************************************/
    234 	void            hash_add (hash_table * table, void *data)
    235 	{
    236 		int             key = *(int *) data;
    237 		int             hash_key = key % table->len;
    238 		hash_entry     *cur = &table->table[hash_key],
    239 		               *new;
    240 	
    241 		if (cur->data)
    242 		{
    243 			new = (hash_entry *) malloc (sizeof (hash_entry));
    244 			new->next = cur->next;
    245 			new->data = data;
    246 			cur->next = new;
    247 		}
    248 		else
    249 		{
    250 			cur->data = data;
    251 			new = cur;
    252 		}
    253 	
    254 		if (table->ordered_last != NULL)
    255 		{
    256 			new->ordered_next = table->ordered_last->ordered_next;
    257 			new->ordered_next->ordered_prev = new;
    258 			new->ordered_prev = table->ordered_last;
    259 			new->ordered_prev->ordered_next = new;
    260 		}
    261 		else
    262 		{
    263 			new->ordered_next = new;
    264 			new->ordered_prev = new;
    265 		}
    266 	
    267 		table->ordered_last = new;
    268 	}
    269 	
    270 	/*******************************************************************************
    271 	 * FUNCTION:	HASH_FIND
    272 	 ******************************************************************************/
    273 	void           *hash_find (hash_table * table, int key)
    274 	{
    275 		int             hash_key = key % table->len;
    276 		hash_entry     *cur = &table->table[hash_key];
    277 	
    278 		while (1)
    279 		{
    280 			if (cur->data && (*(int *) (cur->data) == key))
    281 				return cur->data;
    282 	
    283 			if (cur->next)
    284 				cur = cur->next;
    285 			else
    286 				return NULL;
    287 		}
    288 	}
    289 	
    290 	/*******************************************************************************
    291 	 * FUNCTION:	HASH_DELETE
    292 	 ******************************************************************************/
    293 	void           *hash_delete (hash_table * table, int key)
    294 	{
    295 		int             hash_key = key % table->len;
    296 		hash_entry     *cur = &table->table[hash_key];
    297 		hash_entry     *last = NULL;
    298 		void           *ret_data;
    299 	
    300 	/* step 1: locate key in table */
    301 	
    302 		while (1)
    303 		{
    304 			if (cur->data && (*(int *) (cur->data) == key))
    305 				break;
    306 	
    307 			if (cur->next)
    308 			{
    309 				last = cur;
    310 				cur = cur->next;
    311 			}
    312 			else
    313 			{
    314 				return NULL;
    315 			}
    316 		}
    317 	
    318 		ret_data = cur->data;	/* ret_data is returned at the very end */
    319 	
    320 	/* step 2: unlink entry from ordered list */
    321 	
    322 		cur->ordered_next->ordered_prev = cur->ordered_prev;
    323 		cur->ordered_prev->ordered_next = cur->ordered_next;
    324 	
    325 		if (table->ordered_last == cur)
    326 		{
    327 			if (cur == cur->ordered_prev)
    328 				table->ordered_last = NULL;
    329 			else
    330 				table->ordered_last = cur->ordered_prev;
    331 		}
    332 	
    333 	/* step 3: unlink entry from hashed list */
    334 	
    335 		if (last == NULL)
    336 		{
    337 			if (cur->next)
    338 			{
    339 				hash_entry     *new_next;
    340 	
    341 				cur->data = cur->next->data;
    342 				cur->ordered_next = cur->next->ordered_next;
    343 				cur->ordered_next->ordered_prev = cur;
    344 				cur->ordered_prev = cur->next->ordered_prev;
    345 				cur->ordered_prev->ordered_next = cur;
    346 				if (cur->next == table->ordered_last)
    347 					table->ordered_last = cur;
    348 				new_next = cur->next->next;
    349 				free (cur->next);
    350 				cur->next = new_next;
    351 	
    352 			}
    353 			else
    354 			{
    355 				cur->data = NULL;
    356 			}
    357 		}
    358 		else
    359 		{
    360 			last->next = cur->next;
    361 			free (cur);
    362 		}
    363 	
    364 		return ret_data;
    365 	}
    366 	
    367 	/*******************************************************************************
    368 	 * I used hash_getfirst() and hash_getnext() to free memory reference by the
    369 	 * data referenced by the hash table entries.  Ex:
    370 	 *	free ( (*hash_entry)->data->allocated_string );
    371 	 * The hash_free() command takes care of freeing free ((*hash_entry)->data)
    372 	 *
    373 	 *	--Malcolm 7/29/94
    374 	 ******************************************************************************/
    375 	
    376 	/*
    377 	 * the routines hash_getfirst and hash_getnext use the ordered list of the
    378 	 * hash table. The user passes in a void ** which we use as a reference as a
    379 	 * hash_entry *. These routines may be intermixed with prior hash_* routines
    380 	 * so long as hash_delete is not called on the last item obtained with
    381 	 * getfirst/getnext.
    382 	 */
    383 	
    384 	#undef entry
    385 	#define entry ((hash_entry **)pos)
    386 	
    387 	/*******************************************************************************
    388 	 * FUNCTION:	HASH_GETFIRST
    389 	 ******************************************************************************/
    390 	void           *hash_getfirst (void **pos, hash_table * table)
    391 	{
    392 		if (!table->ordered_last)
    393 			return NULL;
    394 	
    395 		*entry = table->ordered_last->ordered_next;
    396 		if (*entry)
    397 			return (*entry)->data;
    398 		else
    399 			return NULL;
    400 	}
    401 	
    402 	/*******************************************************************************
    403 	 * FUNCTION:	HASH_GETNEXT
    404 	 ******************************************************************************/
    405 	void           *hash_getnext (void **pos, hash_table * table)
    406 	{
    407 		if (*entry == table->ordered_last)
    408 			return NULL;
    409 	
    410 		*entry = (*entry)->ordered_next;
    411 		if (*entry)
    412 			return (*entry)->data;
    413 		else
    414 			return NULL;
    415 	}
    416 	
    417 	#undef entry
    418 	
    419 	/*******************************************************************************
    420 	 * I did not use any of the functions that are defined past this point.
    421 	 *	(Malcolm)
    422 	 ******************************************************************************/
    423 	
    424 	/*
    425 	 * the following routines scan the table unordered. They are more efficient
    426 	 * for deleting individual entries than would be the hash_getnext routine
    427 	 * combined with hash_delete.
    428 	 */
    429 	
    430 	void           *hashloc_init (hash_location * loc, hash_table * table)
    431 	{
    432 		loc->last_row = &table->table[table->len - 1];
    433 		loc->cur_row = table->table;
    434 		loc->prior_entry = NULL;
    435 		loc->table = table;
    436 	
    437 		while (loc->cur_row <= loc->last_row)
    438 		{
    439 			if (loc->cur_row->data)
    440 			{
    441 				loc->cur_entry = loc->cur_row;
    442 				return (loc->cur_entry->data);
    443 			}
    444 	
    445 			loc->cur_row++;
    446 		}
    447 	
    448 		return NULL;
    449 	}
    450 	
    451 	void           *hashloc_getnext (hash_location * loc)
    452 	{
    453 		if (loc->cur_row > loc->last_row)
    454 			return NULL;
    455 	
    456 		if (loc->cur_entry->next)
    457 		{
    458 			loc->prior_entry = loc->cur_entry;
    459 			loc->cur_entry = loc->cur_entry->next;
    460 			return (loc->cur_entry->data);
    461 		}
    462 		else
    463 		{
    464 			loc->prior_entry = NULL;	/* cur_entry will be first item in row */
    465 			while (++loc->cur_row <= loc->last_row)
    466 			{
    467 				if (loc->cur_row->data)
    468 				{
    469 					loc->cur_entry = loc->cur_row;
    470 					return (loc->cur_entry->data);
    471 				}
    472 			}
    473 	
    474 			return NULL;
    475 		}
    476 	}
    477 	
    478 	void           *hashloc_deletenext (hash_location * loc)
    479 	{
    480 		register hash_entry *cur = loc->cur_entry;
    481 	
    482 		if (loc->cur_row > loc->last_row)
    483 			return NULL;
    484 	
    485 		if (loc->table->ordered_last == cur)
    486 		{
    487 			if (cur == cur->ordered_prev)
    488 				loc->table->ordered_last = NULL;
    489 			else
    490 				loc->table->ordered_last = cur->ordered_prev;
    491 		}
    492 	
    493 		cur->ordered_prev->ordered_next = cur->ordered_next;
    494 		cur->ordered_next->ordered_prev = cur->ordered_prev;
    495 	
    496 		if (loc->cur_entry->next)
    497 		{
    498 	
    499 		/*
    500 		 * To delete the current entry, pull next entry's data into
    501 		 * cur_entry, then delete next entry. This way we don't care about
    502 		 * prior_entry, or if we are on the table directly or pointed to by
    503 		 * it
    504 		 */
    505 	
    506 			hash_entry     *free_me = cur->next;
    507 	
    508 			cur->data = free_me->data;
    509 			cur->next = free_me->next;
    510 			cur->ordered_next = free_me->ordered_next;
    511 			cur->ordered_next->ordered_prev = cur;
    512 			cur->ordered_prev = free_me->ordered_prev;
    513 			cur->ordered_prev->ordered_next = cur;
    514 			if (loc->table->ordered_last == free_me)
    515 				loc->table->ordered_last = cur;
    516 			free (free_me);
    517 	
    518 		/* loc->prior_entry is unchanged */
    519 	
    520 			return (cur->data);
    521 		}
    522 		else
    523 		{
    524 	
    525 		/*
    526 		 * To delete the current entry, we must check if we are on the table
    527 		 * directly. If so, don't free anything, just change the data field
    528 		 * to NULL. If not, we must make prior_entry point to NULL, and then
    529 		 * free our location.
    530 		 */
    531 	
    532 			if (loc->prior_entry)
    533 			{
    534 				loc->prior_entry->next = NULL;
    535 				free (cur);
    536 			}
    537 			else
    538 				loc->cur_row->data = NULL;
    539 	
    540 			loc->prior_entry = NULL;
    541 			while (++loc->cur_row <= loc->last_row)
    542 			{
    543 				if (loc->cur_row->data)
    544 				{
    545 					loc->cur_entry = loc->cur_row;
    546 					return (loc->cur_entry->data);
    547 				}
    548 			}
    549 	
    550 			return NULL;
    551 		}
    552 	}



Checking extended ANSI C file safe.c with rules from ansi.cc, posix.cc:

      1 	#define _POSIX_SOURCE	1
------->	                     	A
A: Warning W1005: This definition of _POSIX_SOURCE hides a prior definition.

      2 	/*******************************************************************************
      3 	 * MODULE:	SAFE.C
      4 	 *
      5 	 * PURPOSE:	Contains signal handlers, and reentrant functions that are safe
      6 	 *		to call from within a signal handler.
      7 	 * MOTIVATION:
      8 	 *
      9 	 * The printf()/scanf() functions used in the FIFO module are not re-entrant,
     10 	 * therefore they MUST NOT BE called from within a signal handler (Believe
     11 	 * me, this took me three days to debug.) You must manually build the message
     12 	 * header and send it to the FIFO package via "write()".  POSIX.1 does
     13 	 * guarantee that write() is reentrant.  A list of reentrant functions is
     14 	 * given in section 3.3.1.3 of POSIX.1-1990.  POSIX.1 also says that any
     15 	 * functions listed in the ANSI C standard as reentrant, may be called from
     16 	 * within a signal handler BUT ANSI/ISO 9899-1990 section 7.7.1 says that the
     17 	 * behavior of a signal handler is undefined if it calls any function in the
     18 	 * Standard C library other than signal() itself (to re-register itself as a
     19 	 * signal handler). THE POINT: the only safe functions provided by the
     20 	 * system, are those listed in POSIX.1, and the Standard C "signal()"
     21 	 * function.
     22 	 *
     23 	 * FUNCTIONS DECLARED
     24 	 *	EXTERNAL:	<required>
     25 	 *	LOCAL:		<optional>
     26 	 *
     27 	 * EXTERNAL INTERFACES
     28 	 *	INCLUDES:       <optional>
     29 	 *	GLOBALS:	<optional>
     30 	 *	FILES:		<optional>
     31 	 *	OTHER:		<optional>
     32 	 *
     33 	 * AUTHOR:	Malcolm L. Franklin, Arizona State University
     34 	 * $Author: franklin $
     35 	 *******************************************************************************
     36 	 * $Date: 1994/08/12 17:43:19 $
     37 	 * $State: Exp $
     38 	 * $Locker:  $
     39 	 * $Source: /all/franklin/thesis/descartes/win/RCS/safe.c,v $
     40 	 *
     41 	 ******************************************************************************/
     42 	
     43 	
     44 	
     45 	#if 0
      - 	/******************************************************************************
      - 	 *
      - 	$Log: safe.c,v $
      - 	 * Revision 1.6  1994/08/12  17:43:19  franklin
      - 	 * Echo timeout message to stdout.
      - 	 *
      - 	 * Revision 1.5  1994/08/12  15:55:16  franklin
      - 	 * When printing the timeout message to stdout, put quotes
      - 	 * around it.
      - 	 *
      - 	 * Revision 1.4  1994/08/12  05:03:57  franklin
      - 	 * Correct comments.
      - 	 *
      - 	 * Revision 1.3  1994/08/11  22:53:20  franklin
      - 	 * Perform the SIGALRM timeout() processing inside a
      - 	 * child process, to ensure mutually-exclusive
      - 	 * access to the parent2child FIFO.
      - 	 *
      - 	 * Revision 1.2  1994/08/10  18:56:28  franklin
      - 	 * Provide "right-justified in fieldwidth" and regular integer-to-string
      - 	 * functions.  MUST BE REENTRANT: (safe_int2string_rj() and safe_int2string()).
      - 	 *
      - 	 * Move sigchild_handler() from exec_rtn1.c to this file.
      - 	 * Move sigpipe_handler()  from fifo.c to this file.
      - 	 *
      - 	 * Revision 1.1  1994/08/10  17:23:00  franklin
      - 	 * Initial revision
      - 	 *
      - 	 ******************************************************************************/
     75 	#endif
     76 	
     77 	static char    *rcsid = "$Id: safe.c,v 1.6, h4_3_8 1994/08/12 17:43:19 franklin Exp $";
     78 	
     79 	
     80 	#include <stdlib.h>
     81 	#include "cchk_missing_stdlib.h"       /* Workaround for Spurious CodeCheck diagnostic messages. */
     82 	#include <stdio.h>		       /* Required by exec_rtn.h */
     83 	
     84 	#include <unistd.h>		       /* write() */
     85 	#include "cchk_missing_unistd.h"       /* Workaround for Spurious CodeCheck diagnostic messages. */
     86 	#include <signal.h>		       /* signal() */
     87 	
     88 	#ifdef __CLCC__			       /* Work around CenterLine clcc bogosity handling system header files. */
      - 	
      - 	#ifdef __STDC__
      - 	#undef __STDC__
      - 	#endif
      - 	
      - 	#define __STDC__ 1
     95 	#endif
     96 	
     97 	#include <X11/Intrinsic.h>	       /* required by exec_rtn1.h (definition of type "Widget") */
     98 	#include <Xm/PushBG.h>		       /* required by exec_rtn1.h (definition of type "XmPushButtonCallbackStruct" */
     99 	
    100 	#include "semops.h"		       /* required by fifo.h */
    101 	#include "some_utils.h"		       /* required by fifo.h */
    102 	#include "hash.h"		       /* required by fifo.h */
    103 	#include "fifo.h"
    104 	#include "desc_struct.h"	       /* required by exec_rtn.h */
    105 	#include "exec_rtn1.h"		       /* parent2child FIFO object. */
    106 	#include "safe.h"
    107 	
    108 	/******************************************************************************
    109 	 * FUNCTION:	safe_int2string
    110 	 *	Convert an integer into a character string.
    111 	 ******************************************************************************/
    112 	void            safe_int2string (int val, char buf[])
    113 	{
    114 		int             num;	       /* A modifiable copy of val. */
    115 		int             idx = 0;       /* Index into buf */
    116 		int             digits = 0;    /* Number of decimal digits required to represent an integer. */
    117 		int             digitnum;      /* Left to right (most significant to least significant) offset of the current decimal
    118 					        * digit. */
    119 		int             power_of_10;   /* 10 raised to an integral exponent. */
    120 		int             exponent;      /* The integral exponent to raise 10 to. */
    121 	
    122 		num = val;
    123 		do			/* count the number of digits you need */
    124 		{
    125 			++digits;
    126 			num /= 10;
    127 		} while (num != 0);
    128 	
    129 		num = val;
    130 	
    131 	/*
    132 	 * Build the string from the most significant digit, to the least significant
    133 	 * digit.
    134 	 */
    135 		for (digitnum = digits; digitnum > 0; digitnum--)
    136 		{
    137 			power_of_10 = 1;
    138 			for (exponent = 0; exponent < (digitnum - 1); exponent++)
    139 				power_of_10 *= 10;
    140 	
    141 		/*
    142 		 * Convert to a digit character, assuming the value of the character
    143 		 * '1' == (int)'0' + 1
    144 		 */
    145 			buf[idx] = '0' + (num / power_of_10);
    146 			num %= power_of_10;	/* 359 becomes 59, for example. */
    147 			++idx;
    148 		}
    149 		buf[idx] = 0;
    150 	}
    151 	
    152 	/******************************************************************************
    153 	 * FUNCTION:	safe_int2string_rj
    154 	 *	(Right Justified version of safe_int2string)
    155 	 *	Convert an integer into a character string.  Right-justify the string
    156 	 *	in the specified field width.  The function is "safe_" because it
    157 	 *	contains no writes to static data, and has no other side effects,
    158 	 *	and is therefore -- reentrant.  It is "safe_" to call this function
    159 	 *	from a signal handler (registered with the signal() function).
    160 	 ******************************************************************************/
    161 	void            safe_int2string_rj (int val, char buf[], int fieldwidth)
    162 	{
    163 		int             num;	       /* A modifiable copy of val. */
    164 		int             idx = 0;       /* Index into buf */
    165 		int             digits = 0;    /* Number of decimal digits required to represent an integer. */
    166 		int             digitnum;      /* Left to right (most significant to least significant) offset of the current decimal
    167 					        * digit. */
    168 		int             power_of_10;   /* 10 raised to an integral exponent. */
    169 		int             exponent;      /* The integral exponent to raise 10 to. */
    170 		int             num_blanks;    /* number of blanks (' ') to insert before each integer string written to buf. */
    171 	
    172 		num = val;
    173 		do			/* count the number of digits you need */
    174 		{
    175 			++digits;
    176 			num /= 10;
    177 		} while (num != 0);
    178 	
    179 		num_blanks = fieldwidth - digits;
    180 	
    181 		for (idx = 0; idx < num_blanks; idx++)
    182 			buf[idx] = ' ';
    183 	
    184 		num = val;
    185 	
    186 	/*
    187 	 * Build the string from the most significant digit, to the least significant
    188 	 * digit.
    189 	 */
    190 		for (digitnum = digits; digitnum > 0; digitnum--)
    191 		{
    192 			power_of_10 = 1;
    193 			for (exponent = 0; exponent < (digitnum - 1); exponent++)
    194 				power_of_10 *= 10;
    195 	
    196 		/*
    197 		 * Convert to a digit character, assuming the value of the character
    198 		 * '1' == (int)'0' + 1
    199 		 */
    200 			buf[idx] = '0' + (num / power_of_10);
    201 			num %= power_of_10;	/* 359 becomes 59, for example. */
    202 			++idx;
    203 		}
    204 		buf[idx] = 0;
    205 	}
    206 	
    207 	/******************************************************************************
    208 	 * FUNCTION:	SAFE_STRLEN
    209 	 *****************************************************************************/
    210 	int             safe_strlen (const char buf[])
    211 	{
    212 		int             len = 0;
    213 	
    214 		while (buf[len])
    215 			++len;
    216 		return (len);
    217 	}
    218 	
    219 	/******************************************************************************
    220 	 * FUNCTION:	SAFE_STRCPY
    221 	 *****************************************************************************/
    222 	int             safe_strcpy (char dest[], const char src[])
    223 	{
    224 		int             idx = 0;
    225 	
    226 		while (src[idx])
    227 		{
    228 			dest[idx] = src[idx];
    229 			++idx;
    230 		}
    231 		dest[idx] = '\0';
    232 		return (idx);		/* Returns the length of the copied string. */
    233 	}
    234 	
    235 	
    236 	/******************************************************************************
    237 	 * FUNCTION:	TIMEOUT / TIMEOUT_CHILD
    238 	 *
    239 	 *	Catches SIGALRM signals
    240 	 *	Functionally equivalent to:
    241 	 *		"send2parent (parent2child, SRV_TIMEOUT, "TIMEOUT");"
    242 	 *
    243 	 *	It works, but for very sneaky reasons:  BEWARE
    244 	 *
    245 	 *	Note: timeout() spawns timeout_child(), so that timeout_child() will
    246 	 *	have a different process id than the process that caught the signal.
    247 	 *
    248 	 *	The reason you need a new pid, is so that you will BLOCK when you
    249 	 *	call sem_wait() -- sem_wait() uses advisory record locks on
    250 	 *	a temp file -- it is possible that the main execution thread of the
    251 	 *	process that caught the signal, already had access to parent2child, and
    252 	 *      therefore, would not block when requesting a lock. (Remember, signal
    253 	 *	handlers are a new execution thread WITHIN an existing process.)  You
    254 	 *	cannot write to the FIFO safely, unless you do so as a new process.
    255 	 *
    256 	 *	Another sneaky thing:
    257 	 *	The SRV_TIMEOUT command sendsa process ID to the server, so the server
    258 	 *	can send back a REPLY!  make sure you send the proccess ID of the
    259 	 *	process that caught the SIGALRM signal -- not the PID of the child
    260 	 *	process sending the message.
    261 	 *****************************************************************************/
    262 	static void     timeout_child (int signo, int parent_pid)
    263 	{
    264 		int             command = (int) SRV_TIMEOUT;
    265 	
    266 		char            buf[MSG_HEADER_SIZ + 7 + 1];	/* Message header, the text "TIMEOUT", and a NULL terminator. */
    267 		int             idx = 0;       /* Index into buf */
    268 		static char    *timeoutmsg = "\nIn timeout signal handler, received SIGALRM\n";	/* const, but prototype for write() on
    269 												 * SunOS 4.1.x does not have const in the
    270 												 * prototype. */
    271 		static char    *timeout_text = "TIMEOUT";	/* const, but prototype for write() on SunOS 4.1.x does not have const in
    272 								 * the prototype. */
    273 	
    274 		write (STDOUT_FILENO, timeoutmsg, safe_strlen (timeoutmsg));
    275 	
    276 		safe_int2string_rj (parent_pid, &buf[idx], INTLEN);
    277 		idx += INTLEN;
    278 		buf[idx] = ' ';
    279 		++idx;
    280 	
    281 		safe_int2string_rj (command, &buf[idx], INTLEN);
    282 		idx += INTLEN;
    283 		buf[idx] = ' ';
    284 		++idx;
    285 	
    286 		safe_int2string_rj (safe_strlen (timeout_text), &buf[idx], INTLEN);
    287 		idx += INTLEN;
    288 		buf[idx] = ' ';
    289 		++idx;
    290 	
    291 		safe_strcpy (&buf[idx], timeout_text);
    292 	
    293 	/*
    294 	 * CRITICAL: remember, the parent2child fifo has multiple writers.
    295 	 *
    296 	 * sem_wait() and sem_signal write to no static or global data, and the only
    297 	 * function they call is fcntl(); fcntl() is listed as a "safe" system call
    298 	 * in POSIX.1.  Therefore, sem_wait() and sem_signal() are safe.
    299 	 */
    300 		sem_wait (parent2child->semaphore);
    301 		if (write (parent2child->fd, buf, safe_strlen (buf)) < 0)
    302 		{
    303 			perror ("write() in timeout()");
    304 		}
    305 		sem_signal (parent2child->semaphore);
    306 	
    307 		write (STDOUT_FILENO, "\"", 1);
    308 		write (STDOUT_FILENO, buf, safe_strlen (buf));
    309 		write (STDOUT_FILENO, "\"\n", strlen ("\"\n"));
    310 	
    311 		exit (0);
    312 	}
    313 	void            timeout (int signo)
    314 	{
    315 		int             parent_pid = getpid ();
    316 		int             child_pid;
    317 	
    318 		if ((child_pid = fork ()) == -1)
    319 		{
    320 	
    321 		/*
    322 		 * perror() and util_abort() are not re-entrant, but let the guy say
    323 		 * his dying words.
    324 		 */
    325 			perror ("fork() in timeout()");
    326 			util_abort (__LINE__, __FILE__, "fork() failed in timeout() for process %d\n", getpid ());
    327 		}
    328 	
    329 		/* Do the "real" work in a spawned process.  Do not wait for child to return. */
    330 		if (child_pid == 0)
    331 			timeout_child (signo, parent_pid);
    332 	
    333 		signal (SIGALRM, timeout);	/* Re register yourself for the next SIGALRM signal. */
    334 	}
    335 	
    336 	/******************************************************************************
    337 	 * FUNCTION:	SIGCHLD_HANDLER
    338 	 *	Simply prints a message telling you that a SIGCHLD signal was
    339 	 *	received.
    340 	 *****************************************************************************/
    341 	void            sigchild_handler (int signo)
    342 	{
    343 		char           *part1 = "Process ";	/* const, but prototype for write() on SunOS 4.1.x does not have const in the
    344 							 * prototype. */
    345 		char            part2[INTLEN + 1];
    346 		char           *part3 = " received signal ";	/* const, but prototype for write() on SunOS 4.1.x does not have const in
    347 								 * the prototype. */
    348 		char            part4[INTLEN + 1];	/* const, but prototype for write() on SunOS 4.1.x does not have const in the
    349 							 * prototype. */
    350 		char           *part5 = " (SIGCHLD).\n";
------->		                                 A      
A: Warning W8006: ANSI C does not expand macros inside strings.

    351 	
    352 	
    353 		write (STDOUT_FILENO, part1, safe_strlen (part1));
    354 		safe_int2string (getpid (), part2);
    355 		write (STDOUT_FILENO, part2, safe_strlen (part2));
    356 		write (STDOUT_FILENO, part3, safe_strlen (part3));
    357 		safe_int2string (signo, part4);
    358 		write (STDOUT_FILENO, part4, safe_strlen (part4));
    359 		write (STDOUT_FILENO, part5, safe_strlen (part5));
    360 	
    361 		signal (SIGCHLD, sigchild_handler);
    362 	}
    363 	
    364 	/******************************************************************************
    365 	 * FUNCTION:	SIGPIPE_HANDLER
    366 	 *	Used in FIFO.c to let you know that one of the ends of a pipe died.
    367 	 *****************************************************************************/
    368 	void            sigpipe_handler (int signo)
    369 	{
    370 	
    371 	/*
    372 	 * All of the following static strings are READ ONLY.  The "const" qualifier
    373 	 * was removed, because the prototype for write() on SunOS 4.1.3 did not
    374 	 * specify a const pointer for the second parameter.
    375 	 */
    376 		static char    *part1 = "Process ";
    377 		char            part2[INTLEN + 1];
    378 		static char    *part3 = " caught SIGPIPE signal.  This usually means that the\n";
------->		                                       A                                         
A: Warning W8006: ANSI C does not expand macros inside strings.

    379 		static char    *part4 = "reader process at the end of a pipe or FIFO has died.\n";
    380 		static char    *part5 = "Actual signal number passed to this handler == ";
    381 		char            part6[INTLEN + 1];
    382 		static char    *part7 = ".\n";
    383 	
    384 	
    385 		write (STDOUT_FILENO, part1, safe_strlen (part1));
    386 		safe_int2string (getpid (), part2);
    387 		write (STDOUT_FILENO, part2, safe_strlen (part2));
    388 		write (STDOUT_FILENO, part3, safe_strlen (part3));
    389 		write (STDOUT_FILENO, part4, safe_strlen (part4));
    390 		write (STDOUT_FILENO, part5, safe_strlen (part5));
    391 		safe_int2string (signo, part6);
    392 		write (STDOUT_FILENO, part6, safe_strlen (part6));
    393 		write (STDOUT_FILENO, part7, safe_strlen (part7));
    394 	}
   Warning W8024: Too many macros for some ANSI compilers.



Checking extended ANSI C file semops.c with rules from ansi.cc, posix.cc:

      1 	/*******************************************************************************
      2 	 *
      3 	 * MODULE:	SEMOPS.C
      4 	 *
      5 	 * PURPOSE:	Provide atomic wait() and signal() primitives to provide
      6 	 *		mutual exclusion among processes trying to access a shared
      7 	 *		resource.
      8 	 *
      9 	 * FUNCTIONS:
     10 	 *	EXTERNAL:	sem_create()
     11 	 *			sem_wait()
     12 	 *			sem_signal()
     13 	 *			sem_delete()
     14 	 *
     15 	 * IMPLEMENTATION:
     16 	 *		This module implements binary semaphores by placing locks on
     17 	 *		single bytes within a temporary file.  This is not terribly
     18 	 *		slower than the use of SysV semaphore operations, and unlike
     19 	 *		SysV semaphores, the file locks conform to POSIX.1-1990.
     20 	 *
     21 	 * AUTHOR:	This is a rewrite of the sem.c module.  The original author is
     22 	 *		unknown.  The rewrite was by Malcolm L. Franklin, Arizona State
     23 	 *		University.
     24 	 *******************************************************************************
     25 	 * $Date: 1994/08/06 18:51:27 $
     26 	 * $State: Exp $
     27 	 * $Locker: franklin $
     28 	 * $Source: /all/franklin/thesis/descartes/win/RCS/semops.c,v $
     29 	 *
     30 	 **-M**************************************************************************/
     31 	
     32 	#if 0
      - 	/******************************************************************************
      - 	$Log: semops.c,v $
      - 	 * Revision 1.11  1994/08/06  18:51:27  franklin
      - 	 * sem_open() and sem_close() are not needed by the new
      - 	 * semaphore implementation.  Delete them and all calls to
      - 	 * them.
      - 	 *
      - 	 * Revision 1.10  1994/08/04  18:01:40  franklin
      - 	 * Add #includes for cchk_missing_<standard include>.h in order
      - 	 * to get prototypes that CodeCheck doesnt think are there.
      - 	 *
      - 	 * Revision 1.9  1994/07/25  00:16:05  franklin
      - 	 * Allow for OSs (like Solaris 2.x) that dont #define S_IRUSR and S_IWUSR
      - 	 * bitmask values.
      - 	 *
      - 	 * Revision 1.8  1994/06/15  19:04:36  franklin
      - 	 * Remove debugging printf() statements.
      - 	 *
      - 	 * Revision 1.7  1994/06/02  17:24:01  franklin
      - 	 * Enable stricter type checking when running the CenterLine "clcc" in
      - 	 * K&R compatibility mode (-Xa switch) by re-defining __STDC__ after processing
      - 	 * the non-ansi SunOS system include files.
      - 	 *
      - 	 * Revision 1.6  1994/05/20  20:36:36  franklin
      - 	 * The last couple of characters of the file were chopped off.
      - 	 *
      - 	 * Revision 1.5  1994/05/20  20:28:20  franklin
      - 	 * Return a dummy value from the dummy functions, for now.
      - 	 *
      - 	 * Revision 1.4  1994/05/16  20:02:27  franklin
      - 	 * Use advisory record locks, which are POSIX.1 compliant, to
      - 	 * implement binary semaphores.
      - 	 *
      - 	 ******************************************************************************
      - 	 * Log of this file while the semaphore operations were based on UNIX SYSV
      - 	 * semaphore primitives:
      - 	 *
      - 	 * Revision 1.3  1994/05/13  15:40:17  franklin
      - 	 *  sem_rm() and sem_op() are ONLY called from withing semops.c.  Define
      - 	 * them to be "static" functions (not available for linkage with functions
      - 	 * outside of this file.).
      - 	 *
      - 	 * Revision 1.2  1994/05/02  05:39:41  franklin
      - 	 * Get the declaration of errno and perror() from sunos4_missing.h
      - 	 *
      - 	 * Revision 1.1  1994/05/02  05:20:47  franklin
      - 	 * Initial revision
      - 	 *
      - 	 *
      - 	 ******************************************************************************
      - 	 * Log of this file while it was called sem.c:
      - 	 *
      - 	 * Revision 1.5  1994/05/01  23:42:50  franklin
      - 	 * Last version of this file before it was renamed
      - 	 * semops.c
      - 	 *
      - 	 * Revision 1.4  1994/04/12  13:03:01  franklin
      - 	 * 1. Convert to ANSI function signatures.
      - 	 * 2. Call "perror()" to find out why system calls no worky.
      - 	 *
      - 	 * Revision 1.3  1994/04/08  04:45:20  franklin
      - 	 * Fix compiler warnings
      - 	 *
      - 	 * Revision 1.2  1994/04/08  01:08:22  franklin
      - 	 * Run through SunOS 4.1.3 "indent" program.
      - 	 *
      - 	 ******************************************************************************/
    100 	#endif
    101 	static char    *semops_c_rcsid = "@(#) $Id: semops.c,v 1.11, h4_3_8, h4_3_7, h4_3_6, h4_3_5 1994/08/06 18:51:27 franklin Exp franklin $";
    102 	
    103 	#include  <stdlib.h>
------->	                   A
A: Warning W1000: Precede all headers with #define _POSIX_SOURCE

    104 	#include "cchk_missing_stdlib.h"        /* Workaround for Spurious CodeCheck diagnostic messages. */
    105 	
    106 	#define _POSIX_SOURCE
    107 	#include  <stdio.h>
    108 	#include  <stdarg.h>
    109 	#include  <string.h>
    110 	#include  <unistd.h>
    111 	#include "cchk_missing_unistd.h"       /* Workaround for Spurious CodeCheck diagnostic messages. */
    112 	
    113 	#include  <fcntl.h>
    114 	/******************************************************************************
    115 	 * NOTE TO FUTURE MAINTAINERS USING CenterLine "clcc" COMPILER:
    116 	 *
    117 	 * Nearly all the SunOS 4.x Operating System include files (<sys/xxx.h>)
    118 	 * cause compilation errors under a strict ANSI/ISO compiler running in anal-
    119 	 * retentive mode such as CenterLine "clcc".  In order to get these to compile,
    120 	 * with clcc, you have to pass the  -Xa (K&R C compatibility switch) to the
    121 	 * compiler.  BUT (get this) when we do this, the CenterLine preprocessor
    122 	 * #defines __STDC__ to 0 (zero); when this happens, we dont see the vararg
    123 	 * prototypes for the X functions -- and get warning messages for calling them
    124 	 * with different numbers of arguments.  On top of all this noise, we DONT GET
    125 	 * all the ANSI/ISO C type checking that we could have.
    126 	 *
    127 	 * WORKAROUND:
    128 	 *      When compiling with clcc, #define __STDC__ to 1 AFTER #including the
    129 	 * system header files you need (<sys/xxx.h>), and hopefully before #including
    130 	 * any of the header files you (or I, or Yu-Kuh, or someone else) wrote.
    131 	 * Here is the code:
    132 	 ******************************************************************************/
    133 	#ifdef __CLCC__
      - 	#ifdef __STDC__
      - 	#undef __STDC__
      - 	#endif
      - 	#define __STDC__ 1
    138 	#endif
    139 	
    140 	#include "sunos4_missing.h"
    141 	#include "some_utils.h"		       /* util_abort() */
    142 	#include "semops.h"
    143 	
    144 	/*******************************************************************************
    145 	 * GLOBALS
    146 	 ******************************************************************************/
    147 	static int      semaphore_count = 0;   /* Used to issue semaphore ID's.  This also happens to be the length of the tempfile.
    148 					        * Semaphore ID's are essentially the offset of the byte in the tempfile that is either
    149 					        * locked or unlocked, depending upon whether or not the resource it protects is in use. */
    150 	static int      semaphores_in_use;     /* Count of the number of semaphores in use in the current tempfile.  If this is
    151 					        * decremented back to 0 by sem_delete(), then there are no more semaphores in use; so
    152 					        * delete the tempfile. */
    153 	static int      tempfile_descriptor;   /* We are using POSIX.1 file operations, instead of ANSI/ISO C operations.  This requires
    154 					        * the use of file descriptors rather than FILE pointers. */
    155 	static char     tempfile_name[L_tmpnam];	/* Unique file name obtained from tmpnam().  Note: L_tmpnam is defined in stdio.h */
    156 	
    157 	
    158 	/*******************************************************************************
    159 	 * FUNCTION:	SEM_CREATE
    160 	 *
    161 	 * PUROSE:	Create a new binary semaphore, initialized to  TRUE.  Here I
    162 	 *		mean that an unlocked byte in the tempfile == a semaphore that
    163 	 *		will allow the next requestor to have access to the resource.
    164 	 *
    165 	 * RETURN:	The "id" of the new semaphore.  In this implementation, it
    166 	 *		equals the offset of a byte in the tempfile that is either
    167 	 *		locked or unlocked.
    168 	 * USE:
    169 	 *		int new_semaphore_id;
    170 	 *
    171 	 *		new_semaphore_id = sem_create();
    172 	 ******************************************************************************/
    173 	int             sem_create (void)
    174 	{
    175 		int             new_sem_id;    /* Return valiue */
    176 		const static char *blank_ptr = " ";	/* Points to the byte written to the tempfile whenever a new semaphore is
    177 							 * created. */
    178 		mode_t          tempfile_privileges;
    179 	
    180 		if (semaphore_count == 0)	/* If this is the first time this function has been called. */
    181 		{
    182 			tmpnam (tempfile_name);
    183 		/*
    184 		 * Force creation of a new file, open for read/write.  Give the owner
    185 		 * read and write privileges. see the manpages for open() and stat()
    186 		 * (in chanpter 2  i.e. "man 2 open") for the definitions of the
    187 		 * bitmask values I have bitwise-OR-ed together.
    188 		 */
    189 	#ifndef SOLARIS2
    190 			tempfile_privileges = S_IRUSR | S_IWUSR;
    191 	#else
      - 			tempfile_privileges = 0600;
    193 	#endif
    194 	
    195 		
    196 			if ((tempfile_descriptor = open (tempfile_name, O_CREAT | O_RDWR, tempfile_privileges)) == -1)
    197 			{
    198 				perror ("open() failed in sem_create()");
    199 				util_abort (__LINE__, __FILE__, "Couldn't create a new file.  File name == \"%s\"; Descriptor = %d\n",
    200 					    tempfile_name, tempfile_descriptor);
    201 			}
    202 	
    203 		/*
    204 		 * NOTE: With the "unlink()" call, we are ensuring that the tempfile
    205 		 * gets deleted on process termination. The operating system will not
    206 		 * actually delete the file until the "unlink()"ed file is closed.
    207 		 * The OS automatically closes all files when a process terminates,
    208 		 * so this will be taken care of even if we forget to close() it
    209 		 * ourselves.
    210 		 */
    211 			if (unlink (tempfile_name) == -1)
    212 			{
    213 				perror ("sem_delete() could not unlink() the tempfile");
    214 			}
    215 		}
    216 	
    217 	/*
    218 	 * Append 1 byte to the end of the tempfile and leave it unlocked (semapore
    219 	 * initialized to TRUE).  Note that you can lock byte n of a file, without the 
    220 	 * file being n bytes long.  I did this so I could tell how many semaphores
    221 	 * had been created, by getting a directory listing of the tempfile (ls -l).
    222 	 */
    223 		if (lseek (tempfile_descriptor, semaphore_count * sizeof (char), SEEK_SET) < 0)
    224 		{
    225 			util_abort (__LINE__, __FILE__, "lseek() failed seeking to offset %d in file \"%s\", in sem_create().\n",
    226 				    semaphore_count, tempfile_name);
    227 		}
    228 		if (write (tempfile_descriptor, blank_ptr, sizeof (char)) < 0)
    229 		{
    230 			util_abort (__LINE__, __FILE__, "write() to file \"%s\" failed in sem_create().  semaphore_count == %d.\n",
    231 				    tempfile_name, semaphore_count);
    232 		}
    233 	
    234 	/*
    235 	 * Return the offset of the character you just wrote, as the ID of the new
    236 	 * semaphore.
    237 	 */
    238 		new_sem_id = semaphore_count;
    239 		++semaphore_count;
    240 		++semaphores_in_use;
    241 		return (new_sem_id);
    242 	}
    243 	
    244 	
    245 	/*******************************************************************************
    246 	 * FUNCTION:	SEM_WAIT
    247 	 *
    248 	 * PURPOSE:	If nobody is using the resource protected by semaphore # "id",
    249 	 *		then lock the resource, and give the caller access.  If another
    250 	 *		process is using the resource, then block the calling process
    251 	 *		until the resource is available again.
    252 	 *
    253 	 * PARAMETER:
    254 	 *	INPUT:	int id -- A semaphore id returned from sem_create().
    255 	 ******************************************************************************/
    256 	void            sem_wait (int id)
    257 	{
    258 		struct flock    setlock;
    259 	
    260 		setlock.l_type = F_WRLCK;	/* Obtain an exclusive lock. */
    261 		setlock.l_start = id * sizeof (char);	/* Offset of the record to lock. */
    262 		setlock.l_whence = SEEK_SET;	/* Offset is relative to the beginning of the file. */
    263 		setlock.l_len = sizeof (char);	/* Lock 1 byte. */
    264 	
    265 		if (fcntl (tempfile_descriptor, F_SETLKW, &setlock) < 0)
    266 		{
    267 			perror ("fcntl() failed in sem_wait()");
    268 			util_abort (__LINE__, __FILE__, "Failed to get a lock for semaphore id == %d\n", id);
    269 		}
    270 	}
    271 	
    272 	/*******************************************************************************
    273 	 * FUNCTION:	SEM_SIGNAL
    274 	 *
    275 	 * PURPOSE:	Free a resource so it may be used by another process.
    276 	 *
    277 	 * PARAMETER:
    278 	 *	INPUT:	int id -- A semaphore id returned from sem_create().
    279 	 ******************************************************************************/
    280 	void            sem_signal (int id)
    281 	{
    282 		struct flock    freelock;
    283 	
    284 		freelock.l_type = F_UNLCK;	/* Remove a lock. */
    285 		freelock.l_start = id * sizeof (char);	/* Offset of the record to unlock. */
    286 		freelock.l_whence = SEEK_SET;	/* Offset is relative to the beginning of the file. */
    287 		freelock.l_len = sizeof (char);	/* Unlock 1 byte. */
    288 	
    289 		if (fcntl (tempfile_descriptor, F_SETLK, &freelock) == -1)
    290 		{
    291 			perror ("fcntl () failure in sem_signal()");
    292 			util_abort (__LINE__, __FILE__, "Failed to release a lock for semaphore id == %d\n", id);
    293 		}
    294 	}
    295 	
    296 	/*******************************************************************************
    297 	 * FUNCTION:	SEM_DELETE
    298 	 *
    299 	 * PURPOSE:	Tell this module that you are done using a particular semaphore.
    300 	 *
    301 	 * PARAMETER:
    302 	 *	INPUT:	int id -- A semaphore id returned from sem_create().
    303 	 *
    304 	 * ALGORITHM:
    305 	 *	Doesn't actually care about WHICH semaphore you have deleted, but once
    306 	 *	you have deleted all that are in use, it deletes the tempfile.
    307 	 *
    308 	 * NOTE:
    309 	 *	If you don't delete semaphores when you are done with them, then this
    310 	 *	module will leave its tempfile after the program finishes.
    311 	 ******************************************************************************/
    312 	void            sem_delete (int id)
    313 	{
    314 	printf ("Called sem_delete (%d)\n", id); fflush (stdout);
    315 	
    316 		--semaphores_in_use;
    317 		if (semaphores_in_use == 0)
    318 		{
    319 	
    320 		/*
    321 		 * This close will probably fail if someone still has a lock on the
    322 		 * file.  NOTE: we "unlink()"ed the file immediately after creating
    323 		 * it. The operating system will not actually delete the file until
    324 		 * the file is closed.
    325 		 */
    326 			if (close (tempfile_descriptor) == -1)
    327 			{
    328 				perror ("sem_delete() could not close() the tempfile");
    329 			}
    330 		}
    331 	}
    332 	



Checking extended ANSI C file some_utils.c with rules from ansi.cc, posix.cc:

      1 	/*******************************************************************************
      2 	 * MODULE:      SOME_UTILS.C
      3 	 *
      4 	 * PURPOSE:     Implementation of queues taken from analysis1.c.  Moved to
      5 	 *		this file to improve modularity.
      6 	 *
      7 	 * AUTHOR:      Believed to bi Lih-Shiun Timothy Lee of Arizona State University
      8 	 *******************************************************************************
      9 	 * $Date: 1994/08/05 21:49:57 $
     10 	 * $State: Exp $
     11 	 * $Locker:  $
     12 	 * $Source: /all/franklin/thesis/descartes/win/RCS/some_utils.c,v $
     13 	 *
     14 	 **-M**************************************************************************/
     15 	
     16 	#if 0
      - 	/******************************************************************************
      - 	 *
      - 	$Log: some_utils.c,v $
      - 	 * Revision 1.17  1994/08/05  21:49:57  franklin
      - 	 * Allow const char pointers to be passed to
      - 	 * growbuf_strcpy() and growbuf_strcat().
      - 	 *
      - 	 * Revision 1.16  1994/08/04  22:36:00  franklin
      - 	 * workaround CodeCheck inability to handle ANSI variable argument lists.
      - 	 *
      - 	 * Revision 1.15  1994/08/04  18:03:02  franklin
      - 	 * Add #includes for cchk_missing_<standard include>.h in order
      - 	 * to get prototypes that CodeCheck doesnt think are there.
      - 	 *
      - 	 * Revision 1.14  1994/08/03  15:59:11  franklin
      - 	 * Changed "unsigned long" to "unsigned long int" to shut up a
      - 	 * CodeCheck diagnostic.
      - 	 *
      - 	 * Revision 1.13  1994/08/02  13:33:52  franklin
      - 	 * isqempty -> qisempty (prefix "is" is reserved by ctype.h)
      - 	 *
      - 	 * Revision 1.12  1994/08/01  23:32:47  franklin
      - 	 * Suffix _t is reserved by POSIX.  Change growbuf_t to growbuf_tt.
      - 	 *
      - 	 * Revision 1.11  1994/07/31  21:49:46  franklin
      - 	 * Fix a spurious Purify(tm) uninitialized memory read error, caused by
      - 	 * "strlen()" fetching a full word at a time, versus a byte at a time, while
      - 	 * searching for the null terminator of a string.
      - 	 *
      - 	 * Revision 1.10  1994/07/30  23:43:37  franklin
      - 	 * Fix an uninitialized memory read detected by Purify.  The
      - 	 * umr occured when you executed growbuf_strcpy (gbuf, "");
      - 	 *
      - 	 * Revision 1.9  1994/07/06  04:56:50  franklin
      - 	 * Add a function to return a pointer to "fred.stuff" when passed
      - 	 * a pointer to "/all/me/you/fred.stuff" (get_base_filename())
      - 	 *
      - 	 * Revision 1.8  1994/07/05  02:03:38  franklin
      - 	 * Added function "load_file_into_charbuf()" for reading a file
      - 	 * into a character buffer in heap storage.
      - 	 *
      - 	 * Revision 1.7  1994/06/02  17:24:35  franklin
      - 	 * Enable stricter type checking when running the CenterLine "clcc" in
      - 	 * K&R compatibility mode (-Xa switch) by re-defining __STDC__ after processing
      - 	 * the non-ansi SunOS system include files.
      - 	 *
      - 	 * Revision 1.6  1994/05/24  02:06:36  franklin
      - 	 * Cast pointer returned by calloc() to the proper type.
      - 	 *
      - 	 * Revision 1.5  1994/05/21  20:45:00  franklin
      - 	 * Add the "growbuf" utilities, for storing/appending strings of arbitrary
      - 	 * length.  The buffer grows as more space is needed.
      - 	 *
      - 	 * Revision 1.4  1994/05/13  22:12:13  franklin
      - 	 * Add util_abort(), and run through SunOS "indent" utility.
      - 	 *
      - 	 * Revision 1.3  1994/04/24  00:53:09  franklin
      - 	 * Add a function to print integer values in binary format.
      - 	 *
      - 	 * Revision 1.2  1994/04/23  16:15:09  franklin
      - 	 * Get the declarations of "free()" and "printf()" from system header files.
      - 	 *
      - 	 * Revision 1.1  1994/04/12  07:41:09  franklin
      - 	 * Initial revision
      - 	 *
      - 	 ******************************************************************************/
     83 	#endif
     84 	static char    *rcsid = "$Id: some_utils.c,v 1.17, h4_3_8, h4_3_7, h4_3_6, h4_3_5 1994/08/05 21:49:57 franklin Exp $";
     85 	
     86 	#include <stdlib.h>
------->	                  A
A: Warning W1000: Precede all headers with #define _POSIX_SOURCE

     87 	#include "cchk_missing_stdlib.h"       /* Workaround for Spurious CodeCheck diagnostic messages. */
     88 	#include <stdarg.h>
     89 	#include "cchk_missing_stdarg.h"       /* Workaround for Spurious CodeCheck diagnostic messages. */
     90 	#include <limits.h>
     91 	#include <stdio.h>
     92 	#include <string.h>
     93 	#include <unistd.h>
     94 	#include "cchk_missing_unistd.h"       /* Workaround for Spurious CodeCheck diagnostic messages. */
     95 	/******************************************************************************
     96 	 * NOTE TO FUTURE MAINTAINERS USING CenterLine "clcc" COMPILER:
     97 	 *
     98 	 * Nearly all the SunOS 4.x Operating System include files (<sys/xxx.h>)
     99 	 * cause compilation errors under a strict ANSI/ISO compiler running in anal-
    100 	 * retentive mode such as CenterLine "clcc".  In order to get these to compile,
    101 	 * with clcc, you have to pass the  -Xa (K&R C compatibility switch) to the
    102 	 * compiler.  BUT (get this) when we do this, the CenterLine preprocessor
    103 	 * #defines __STDC__ to 0 (zero); when this happens, we dont see the vararg
    104 	 * prototypes for the X functions -- and get warning messages for calling them
    105 	 * with different numbers of arguments.  On top of all this noise, we DONT GET
    106 	 * all the ANSI/ISO C type checking that we could have.
    107 	 *
    108 	 * WORKAROUND:
    109 	 *      When compiling with clcc, #define __STDC__ to 1 AFTER #including the
    110 	 * system header files you need (<sys/xxx.h>), and hopefully before #including
    111 	 * any of the header files you (or I, or Yu-Kuh, or someone else) wrote.
    112 	 * Here is the code:
    113 	 ******************************************************************************/
    114 	
    115 	#ifdef __CLCC__
      - 	
      - 	#ifdef __STDC__
      - 	#undef __STDC__
      - 	#endif
      - 	
      - 	#define __STDC__ 1
    122 	#endif
    123 	
    124 	#include "some_utils.h"
    125 	
    126 	/*******************************************************************************
    127 	 *******************************************************************************
    128 	 ** QUEUE UTILITIES
    129 	 **
    130 	 **	comprized of:	qisempty();	vfront();	dequeue();
    131 	 **			enqueue();
    132 	 *******************************************************************************
    133 	 ******************************************************************************/
    134 	
    135 	
    136 	/*******************************************************************************
    137 	 * FUNCTION:	QISEMPTY
    138 	 *	Return 1 if q is empty; otherwise return 0
    139 	 ******************************************************************************/
    140 	int             qisempty (QUEUE * q)
    141 	{
    142 		if (q->front == NULL)
    143 			return (1);
    144 		else
    145 			return (0);
    146 	}
    147 	
    148 	/*******************************************************************************
    149 	 * FUNCTION:	VFRONT
    150 	 *	Return the value if the first element
    151 	 ******************************************************************************/
    152 	SDATA           vfront (QUEUE * q)
    153 	{
    154 		return (q->front->d);
    155 	
    156 	}
    157 	
    158 	/*******************************************************************************
    159 	 * FUNCTION:	DEQUEUE
    160 	 *	Return the value if the first element and remove it
    161 	 ******************************************************************************/
    162 	void            dequeue (QUEUE * q, SDATA * x)
    163 	{
    164 		SLINK           temp = q->front;
    165 	
    166 		if (!qisempty (q))
    167 		{
    168 			printf ("before dqueue\n");
    169 			*x = temp->d;
    170 			printf ("before dqueue\n");
    171 			q->front = temp->next;
    172 			free (temp);
    173 		}
    174 		else
    175 			printf ("empty  queue. \n");
    176 	
    177 	}
    178 	
    179 	/*******************************************************************************
    180 	 * FUNCTION:	ENQUEUE
    181 	 *	Place the value d onto the rear of q
    182 	 ******************************************************************************/
    183 	void            enqueue (QUEUE * q, SDATA x)
    184 	{
    185 		SLINK           temp;
    186 	
    187 		printf ("before enqueue\n");
    188 		temp = (SLINK) malloc (sizeof (SELEMENT));
    189 		printf (" enqueue\n");
    190 		temp->d = x;
    191 		temp->next = 0;
    192 	
    193 		if (qisempty (q) == 1)
    194 		{
    195 			q->front = q->rear = temp;
    196 			printf ("empty\n");
    197 		}
    198 		else
    199 		{
    200 			q->rear->next = temp;
    201 			q->rear = temp;
    202 			printf ("not empty\n");
    203 		}
    204 		printf (" after enqueue\n");
    205 	}
    206 	
    207 	/*******************************************************************************
    208 	 *******************************************************************************
    209 	 ** DUMP_BITS_UTILITY
    210 	 **
    211 	 **	comprized of only 1 function: dump_bits()
    212 	 *******************************************************************************
    213 	 ******************************************************************************/
    214 	
    215 	/*******************************************************************************
    216 	 * FUNCTION:	DUMP_BITS
    217 	 *
    218 	 * PURPOSE:	Prints integers to a given file in binary format.
    219 	 *		The input value is declared to be of type unsigned long int,
    220 	 *		so that it can work for any size integer value you want (int,
    221 	 *		long, or short).
    222 	 *
    223 	 * PARAMETERS
    224 	 *	INPUT:	outf  -- Output file
    225 	 * 		val   -- Value you want to print
    226 	 *
    227 	 * USE:
    228 	 *	dump_bits (stdout, 1 | 8) writes the following to stdout():
    229 	 *		1001
    230 	 *
    231 	 *	dump_bits (stdout, 1 << 31) writes the following to stdout (provided
    232 	 *	words are at least 32 bits wide on your machine).
    233 	 *
    234 	 *	1000 0000 0000 0000 0000 0000 0000 0000 0000
    235 	 ******************************************************************************/
    236 	void            dump_bits (FILE * outf, unsigned long int val)
------->	                                                             A
A: Warning W8025: non-ANSI unsigned type.

    237 	{
    238 		static int      bits_per_word = 0;
    239 		unsigned long int bits_to_go;
------->		                            A
A: Warning W8025: non-ANSI unsigned type.

    240 		unsigned long int mask;
------->		                      A
A: Warning W8025: non-ANSI unsigned type.

    241 		int             count;
    242 	
    243 	/*
    244 	 * On the first call to this function, compute how many bits are in an
    245 	 * unsigned long int.  (I assume that there will be a nonzero number of bits
    246 	 * in a word.
    247 	 */
    248 	
    249 		if (bits_per_word == 0)
    250 		{
    251 			bits_to_go = ULONG_MAX;
    252 			while (bits_to_go)
    253 			{
    254 				++bits_per_word;
    255 				bits_to_go >>= 1;
    256 			}
    257 		}
    258 	
    259 	/*
    260 	 * Set only the most-significant-bit in "mask".  We'll shift the set bit in
    261 	 * mask from the most-significant-bit to the least significant bit.
    262 	 */
    263 		mask = 1 << (bits_per_word - 1);
    264 		count = 0;
    265 	
    266 	/*
    267 	 * Skip past any leading groups of four '0' bits ("0000"). so you print
    268 	 * decimal 9 as  "0001 0000", and decimal 2 as "0010".  Always print at least
    269 	 * one group of zeros (zero should print as "0000", not a null string).
    270 	 */
    271 		while ((count < (bits_per_word - 4)) &&
    272 				!(val & (0xF << (bits_per_word - (count + 4)))))
    273 		{
    274 			count += 4;
    275 			mask >>= 4;
    276 		}
    277 	
    278 		while (mask)
    279 		{
    280 			if (mask & val)
    281 				fputc ('1', outf);
    282 			else
    283 				fputc ('0', outf);
    284 	
    285 		/* Print a space between each group of 4 bits. */
    286 			++count;
    287 			if ((count < bits_per_word) && ((count % 4) == 0))
    288 				fputc (' ', outf);
    289 	
    290 			mask >>= 1;
    291 		}
    292 	}
    293 	
    294 	/*******************************************************************************
    295 	 *******************************************************************************
    296 	 ** GROWBUF UTILITIES:
    297 	 **
    298 	 **	comprized of:	growbuf_init() 	growbuf_strcpy()	growbuf_strcat()
    299 	 **			growbuf_strcpy()growbuf_str()		free_growbuf()
    300 	 **
    301 	 ** PURPOSE:	Implement a character buffer, which grows to the size of the
    302 	 **		largest object stored in it.  Useful for making a copy of a
    303 	 **		string whose size is not known until runtime.
    304 	 **
    305 	 ** USE:	You must initialize the new growbuf_tt objects by calling
    306 	 **		growbuf_init().  Example usage of the growbuf functions:
    307 	 **
    308 	 **			char *unknown_len_str;
    309 	 **			growbuf_tt *gbuf;
    310 	 **
    311 	 **			growbuf_init (&gbuf);
    312 	 **			while (get_unknown_len_str(unknown_len_str))
    313 	 **			{
    314 	 **				growbuf_strcpy(gbuf, unknown_len_str);
    315 	 **				printf("growbuf_str(gbuf) == \"%s\%\n",
    316 	 **							growbuf_str(gbuf));
    317 	 **			}
    318 	 **			growbuf_free (&gbuf);
    319 	 **
    320 	 **		If you want to keep a pointer to the string stored in the
    321 	 **		growbuf, then manually free the growbuf_tt struct when you
    322 	 **		are finished with it, and do NOT call growbuf_free():
    323 	 **
    324 	 **			growbuf_init (&gbuf);
    325 	 **				...
    326 	 **			keep_str = growbuf_str(gbuf);
    327 	 **			free(gbuf)
    328 	 *******************************************************************************
    329 	 ******************************************************************************/
    330 	
    331 	
    332 	/*******************************************************************************
    333 	 * FUNCTION:	GROWBUF_INIT
    334 	 *	Initializes a new growbuf.  You MUST call this function on each growbuf
    335 	 *	BEFORE calling any of the other growbuf functions.
    336 	 *
    337 	 * NOTE:        Users only declare POINTERS to growbuf_tt structures; pass the
    338 	 *              address of the pointer to this function.
    339 	 *
    340 	 * USE:         growbuf_tt *my_gbuf;
    341 	 *              growbuf_init (&my_gbuf);
    342 	 ******************************************************************************/
    343 	void            growbuf_init (growbuf_tt ** gbuf)
    344 	{
    345 	/* Calloc initializes (*gbuf)->cur_len to zero and (*gbuf)->buf to NULL. */
    346 		*gbuf = (growbuf_tt *) calloc (1, sizeof (growbuf_tt));
    347 		if (*gbuf == NULL)
    348 		{
    349 			util_abort (__LINE__, __FILE__, "growbuf_init() could not calloc() storage for a growbuf_tt struct.\n"
    350 				    "sizeof (growbuf_tt) == %d\n", sizeof (growbuf_tt));
    351 		}
    352 	}
    353 	
    354 	/*******************************************************************************
    355 	 * FUNCTION:	GROWBUF_STR
    356 	 *	Returns a pointer to the character string stored in the growbuf.
    357 	 ******************************************************************************/
    358 	char           *growbuf_str (growbuf_tt * gbuf)
    359 	{
    360 		return (gbuf->buf);
    361 	}
    362 	
    363 	/*******************************************************************************
    364 	 * FUNCTION:	GROWBUF_FREE
    365 	 *	frees dynamically-allocated storage referenced by the growbuf_tt
    366 	 *	buffer, and the storage for the growbuf_tt strucure itself.
    367 	 *
    368 	 * NOTE:        Users only declare POINTERS to growbuf_tt structures; pass the
    369 	 *              ADDRESS of the pointer to this function.
    370 	 *
    371 	 * USE:         growbuf_tt *my_gbuf;
    372 	 *              growbuf_free (&my_gbuf);
    373 	 ******************************************************************************/
    374 	void            growbuf_free (growbuf_tt ** gbuf)
    375 	{
    376 		free ((*gbuf)->buf);
    377 		free (*gbuf);
    378 		*gbuf = NULL;		/* Do not leave a pointer into de-allocated memory. */
    379 	}
    380 	
    381 	
    382 	/*******************************************************************************
    383 	 * FUNCTION:	GROW_THE_BUFFER
    384 	 *
    385 	 * PURPOSE:	Ensure that gbuf->buf is pointing to a buffer large enough to
    386 	 *		hold the arbirary-length string passed to this function.
    387 	 *
    388 	 * NOTE:	This is an INTERNAL function to the growbuf routines.  It is
    389 	 *		not intended for use by user code.
    390 	 *
    391 	 *		This function allways assumes you are appending a string to
    392 	 *		the growstrings buffer.  If you want to replace the string
    393 	 *		pointed to by gbuf->buf, then set gbf->buf[0] == '\0' before
    394 	 *		calling this function.
    395 	 ******************************************************************************/
    396 	static void     grow_the_buffer (growbuf_tt * gbuf, const char *in_str)
    397 	{
    398 		const size_t    increment = 32;/* Grow the buffer in 32 byte increments. */
    399 		size_t          desired_len;
    400 	
    401 	/*
    402 	 * If no storage has been allocated for gbuf->buf, or if we are copying,
    403 	 * rather than appending a string to the buffer.
    404 	 */
    405 		if ((gbuf->buf == NULL) || (gbuf->buf[0] == '\0'))
    406 		{
    407 			desired_len = strlen (in_str);
    408 		}
    409 		else
    410 		{
    411 			desired_len = strlen (in_str) + strlen (gbuf->buf);
    412 		}
    413 	
    414 	/*
    415 	 * Do not increase the buffer size unless you have to.  Leave room for the
    416 	 * '\0' terminator.
    417 	 */
    418 		while ((desired_len + 1) > gbuf->cur_len)
    419 		{
    420 	
    421 		/*
    422 		 * Even though the ANSI/ISO C standard says that realloc() will
    423 		 * return a newly-allocated block when passed a NULL pointer, several
    424 		 * UNIX systems do not support this.  Manually allocate new buffers.
    425 		 */
    426 	
    427 			if (gbuf->buf == NULL)
    428 			{
    429 				gbuf->cur_len = 0;
    430 				if ((gbuf->buf = malloc ((increment + 1))) == NULL)
    431 				{
    432 					util_abort (__LINE__, __FILE__, "growbuf() failed to allocate new storage for gbuf.\n");
    433 				}
    434 	
    435 			/*
    436 			 * Workaround for a spurious Purify(tm) umr message.  You
    437 			 * must initialize a full word of buf to '\0' to prevent a
    438 			 * false umr error when calling strlen() on a newly created
    439 			 * growbuf->buf string.
    440 			 */
    441 				memset (gbuf->buf, 0, sizeof (int));
    442 			}
    443 			gbuf->cur_len += increment;
    444 			if ((gbuf->buf = realloc (gbuf->buf, (gbuf->cur_len + 1))) == NULL)
    445 			{
    446 				util_abort (__LINE__, __FILE__, "growbuf() failed to get more memory for your buffer via realloc().\n"
    447 					    "buffer at 0x%X; length attempted = %d, desired length = %d\n"
    448 					    "increment = %d.\n", gbuf->buf, gbuf->cur_len, desired_len, increment);
    449 			}
    450 		}
    451 	}
    452 	
    453 	/*******************************************************************************
    454 	 * FUNCTION:	GROWBUF_STRCPY
    455 	 *
    456 	 * PURPOSE:	Copy a string of arbitrary length to gbuf->buf;  overwrite any
    457 	 *		data previously written to the buffer.
    458 	 *
    459 	 * PARAMETERS
    460 	 *	INPUT:	growbuf_tt *gbuf -- A pointer to your growbuf struct
    461 	 *		char *in_str    -- A pointer to the string that you want to
    462 	 *                                 store in the buffer.
    463 	 ******************************************************************************/
    464 	void            growbuf_strcpy (growbuf_tt * gbuf, const char *in_str)
    465 	{
    466 	
    467 	/*
    468 	 * If storage for gbuf->buf has already been allocated, then zap the string
    469 	 * stored in gbuf->buf, because grow_the_buffer() assumes you want to append
    470 	 * in_str to gbuf->buf.
    471 	 */
    472 		if (gbuf->buf != NULL)
    473 		{
    474 			gbuf->buf[0] = '\0';
    475 		}
    476 		grow_the_buffer (gbuf, in_str);
    477 		gbuf->buf[0] = '\0';	/* grow_the_buffer() may have just malloc()ed gbuf->buf for the first time. */
    478 		strcpy (gbuf->buf, in_str);
    479 	}
    480 	
    481 	/*******************************************************************************
    482 	 * FUNCTION:	GROWBUF_STRCAT
    483 	 *
    484 	 * PURPOSE:	Append a string of arbitrary length to the strina stored in
    485 	 *		gbuf->buf.
    486 	 *
    487 	 * PARAMETERS
    488 	 *	INPUT:	growbuf_tt *gbuf -- A pointer to your growbuf struct
    489 	 *		char *in_str    -- A pointer to the string that you want to
    490 	 *                                 store in the buffer.
    491 	 ******************************************************************************/
    492 	void            growbuf_strcat (growbuf_tt * gbuf, const char *in_str)
    493 	{
    494 		grow_the_buffer (gbuf, in_str);
    495 		strcat (gbuf->buf, in_str);
    496 	}
    497 	
    498 	/*******************************************************************************
    499 	 *******************************************************************************
    500 	 ** FILE UTILITY
    501 	 **
    502 	 **	comprized of:	get_base_filename();
    503 	 **			load_file_into_charbuf();
    504 	 *******************************************************************************
    505 	 ******************************************************************************/
    506 	
    507 	/*******************************************************************************
    508 	 * FUNCTION:	GET_BASE_FILENAME
    509 	 *
    510 	 * PURPOSE:	Return the name of the file, without the path to it.  Returns
    511 	 *		NULL if passed a null pointer, otherwise returns a pointer in
    512 	 *		to the string you passed to it.
    513 	 ******************************************************************************/
    514 	const char     *get_base_filename (const char *fullpathname)
    515 	{
    516 		const char     *fname;
    517 	
    518 		if (fullpathname)
    519 		{
    520 			fname = fullpathname + strlen (fullpathname) - 1;
    521 			if (fname < fullpathname)	/* if fullpathname points to a zero-length string */
    522 			{
    523 				fname = fullpathname;
    524 			}
    525 			else
    526 			{
    527 			/* Search for a directory separator character. */
    528 				while ((fname >= fullpathname) && (*fname != '/'))
    529 					--fname;
    530 				if (*fname == '/')
    531 					++fname;
    532 			}
    533 		}
    534 		else
    535 		{
    536 			fname = NULL;
    537 		}
    538 		return (fname);
    539 	}
    540 	
    541 	/*******************************************************************************
    542 	 * FUNCTION:	LOAD_FILE_INTO_CHARBUF
    543 	 *
    544 	 * PURPOSE:	Reads the contents of a file into a character array.
    545 	 *
    546 	 * PARAMETERS:
    547 	 *	INPUT:	char *pathname -- Name of a file that IS NOT being read/
    548 	 *				  written to by anyone else.
    549 	 *
    550 	 * RETURNS:	NULL if it cannot open the file, or get memory from the heap.
    551 	 *
    552 	 * WARNING:	Caller must free() the pointer passed back from this function
    553 	 *
    554 	 ******************************************************************************/
    555 	char           *load_file_into_charbuf (const char *pathname, int *len)
    556 	{
    557 		FILE           *infile;
    558 		int             filesize;
    559 		char           *file_contents;
    560 	
    561 		file_contents = NULL;
    562 		filesize = 0;
    563 	
    564 		if ((infile = fopen (pathname, "rb")) != NULL)
    565 		{
    566 			fseek (infile, 0L, SEEK_END);
    567 			filesize = ftell (infile);
    568 			rewind (infile);
    569 			if ((file_contents = malloc (filesize + 1)) != NULL)
    570 			{
    571 				if (fread (file_contents, 1, filesize, infile) == filesize)
    572 					file_contents[filesize] = '\0';
    573 				else
    574 				{
    575 					free (file_contents);
    576 					file_contents = NULL;
    577 				}
    578 			}
    579 			fclose (infile);
    580 		}
    581 		*len = filesize;
    582 		return (file_contents);
    583 	}
    584 	
    585 	/*******************************************************************************
    586 	 *******************************************************************************
    587 	 ** ABORT UTILITIY:
    588 	 **
    589 	 **	comprized of only 1 function:	util_abort();
    590 	 *******************************************************************************
    591 	 ******************************************************************************/
    592 	
    593 	/*******************************************************************************
    594 	 * Function:    UTIL_ABORT
    595 	 *
    596 	 *      Use to kill the program and leave a traceback stack.  This is intended
    597 	 *      for errors such as malloc() failures, or garbled datatypes, that
    598 	 *      prevent all hope of recovery, and leave no chance of producing anything
    599 	 *      resembling meaningful results.
    600 	 *
    601 	 *	USAGE:
    602 	 *	if ( (ptr=malloc(...)) == NULL )
    603 	 *		util_abort ( __LINE__, __FILE__, "malloc() failed. ptr == %X\n", ptr );
    604 	 *
    605 	 *      printf_fmt_str and any additional parameters behave like printf(), and
    606 	 *	use printf() format and escape sequences.
    607 	 ******************************************************************************/
    608 	void            util_abort (int line, char *file, char *printf_fmt_str,...)
    609 	{
    610 		va_list         arguments;
    611 	
    612 		va_start (arguments, printf_fmt_str);
    613 		fflush (stdout);
    614 		fprintf (stderr, "\n*---- Aborting on line %d of file \"%s\". ----*\nReason:\n", line, file);
    615 		fflush (stderr);
    616 		vfprintf (stderr, printf_fmt_str, arguments);
    617 		fflush (stderr);
    618 		abort ();
    619 		va_end (arguments);
    620 	}


